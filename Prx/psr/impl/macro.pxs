// Prexonite
// 
// Copyright (c) 2011, Christian Klauser
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without modification, 
//  are permitted provided that the following conditions are met:
// 
//     Redistributions of source code must retain the above copyright notice, 
//          this list of conditions and the following disclaimer.
//     Redistributions in binary form must reproduce the above copyright notice, 
//          this list of conditions and the following disclaimer in the 
//          documentation and/or other materials provided with the distribution.
//     The names of the contributors may be used to endorse or 
//          promote products derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
//  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function macro\macro_pxs_module[compiler] = asm(ldr.app).Module.Name;

function is_in_macro\impl as is_in_macro(context) [is compiler;] = 
    ([context.Function]
    >> append(context.GetParentFunctions())
    >> where(f => f.Meta[Prexonite::Compiler::CompilerTarget.MacroMetaKey].Switch)
    >> limit(1)
    >> count) > 0;
    
// establish_macro_context - Allows a macro, that only works in other macros, to be applied in nested functions of macros as well.
function establish_macro_context\impl as establish_macro_context(context) [is compiler;]
{
    if(context is null)
        throw @"establish_macro_context\impl: context cannot be null.";
    var contextAlias = Prexonite::Compiler::MacroAliases.ContextAlias;
    if(not is_in_macro(context)) 
    {
        context.ReportMessage(Prexonite::Compiler::MessageSeverity.Error, "Cannot establish macro context outside of macro", context.Invocation);
        return;
    }

    if(not (context.OuterVariables >> map(?.ToUpperInvariant) >> contains(contextAlias.ToUpperInvariant)))
        context.RequireOuterVariable(contextAlias);
}

// ast\macro - Works like ast from psr\ast.pxs but automatically supplies file, line and column information 
//    taken from the macro invocation. 
macro ast\macro(type)[partial\macro]
{   
    var macroInvocation = context.Invocation;
    
    ref ast = ast\withPos(?,macroInvocation.File, macroInvocation.Line,macroInvocation.Column,?);
    ref ast3 = ast3\withPos(context.Factory,?,macroInvocation.Position,?);
    
    if(SI.eq(context.Call,SI.set))
    {
        context.ReportMessage(Prexonite::Compiler::MessageSeverity.Error,
            "AST node construction has no side-effects. Ignoring the return value doesn't make sense.",
            context.Invocation);
        return false;
    }
    
    var astCall = ast3("IndirectCall", ast3("Reference",entityref_to(ast\withPos)), SI.get);
    
    var nodeFile;
    var nodeLine;
    var nodeColumn;
    
    var invkV = null;
    
    if(is_in_macro(context))
    {
        establish_macro_context(context);
        
        var getContext = ast3("IndirectCall",ast3("IndirectCall", ast3("Reference",SI.e.lvar(Prexonite::Compiler::MacroAliases.ContextAlias)), SI.get), SI.get);
        
        var getInvComp = ast("GetSetMemberAccess",SI.get,getContext,"Invocation");
            
        var invkV = context.AllocateTemporaryVariable();
        var storeInvk = ast3("IndirectCall", ast3("Reference",SI.e.lvar(invkV)), SI.set);
        storeInvk.Arguments.Add(getInvComp);
        
        var getInv = ast3("IndirectCall", ast3("Reference", SI.e.lvar(invkV)), SI.get);
            
        nodeFile = ast("GetSetMemberAccess", SI.get, storeInvk, "File");
        nodeLine = ast("GetSetMemberAccess", SI.get, getInv, "Line");
        nodeColumn = ast("GetSetMemberAccess", SI.get, getInv, "Column");
    }
    else 
    {
        nodeFile = ast("Constant",macroInvocation.File);
        nodeLine = ast("Constant",macroInvocation.Line);
        nodeColumn = ast("Constant",macroInvocation.Column);
    }
    
    astCall.Arguments.AddRange([type,nodeFile, nodeLine, nodeColumn ]);
    astCall.Arguments.AddRange(var args >> skip(1));
    
    context.Block.Expression = astCall;
    
    if(invkV is not null)
        context.FreeTemporaryVariable(invkV);
    
    return true;
}

function reify_position(context, position)[compiler]{
	var pos = context.Invocation.Position;
	var create = context.Factory;
	
	var ctorNode = create.ObjectCreation(pos,create.ConstantTypeExpression(pos,"Object(\"Prexonite.Compiler.SourcePosition\")"));
	ctorNode.Arguments.Add(create.Constant(pos, position.File));
	ctorNode.Arguments.Add(create.Constant(pos, position.Line));
	ctorNode.Arguments.Add(create.Constant(pos, position.Column));
	return ctorNode;
}

// ast2\macro - Works like ast from psr\ast.pxs but automatically supplies source position information 
//    taken from the macro invocation. 
macro ast2\macro(type)[partial\macro]
{   
    var macroInvocation = context.Invocation;
    
    ref ast = ast\withPos(?,macroInvocation.File, macroInvocation.Line,macroInvocation.Column,?);
    ref ast3 = ast3\withPos(context.Factory,?,macroInvocation.Position,?);
    
    if(SI.eq(context.Call,SI.set))
    {
        context.ReportMessage(Prexonite::Compiler::MessageSeverity.Error,
            "AST node construction has no side-effects. Ignoring the return value doesn't make sense.",
            context.Invocation.Position);
        return false;
    }
    
    var astCall = ast3("IndirectCall", ast3("Reference", entityref_to(ast\withPos)), SI.get);
    
    var nodePosition;
    
    if(is_in_macro(context))
    {
        establish_macro_context(context);
        
        var getContext = ast3("IndirectCall", ast3("IndirectCall", ast3("Reference", SI.e.lvar(Prexonite::Compiler::MacroAliases.ContextAlias)), SI.get), SI.get);
        
        var getInvComp = ast("GetSetMemberAccess",SI.get,getContext,"Invocation");
        
        nodePosition = ast("GetSetMemberAccess", SI.get, getInvComp, "Position");
    }
    else 
    {
        nodePosition = reify_position(context,macroInvocation.Position);
    }
    
    astCall.Arguments.AddRange([type,nodePosition ]);
    astCall.Arguments.AddRange(var args >> skip(1));
    
    context.Block.Expression = astCall;
    
    return true;
}

// Change where the ast and ast2 aliases point to.
//    do not add these aliases directly to the macros, because their implementations
//    expect the old aliases to be intact.
declare: ast\macro as ast;
declare: ast2\macro as ast2;

macro ast3\macro(type)[partial\macro]
{
    if(SI.eq(context.Call,SI.set))
    {
        context.ReportMessage(Prexonite::Compiler::MessageSeverity.Error,
            "AST node construction has no side-effects. Ignoring the return value doesn't make sense.",
            context.Invocation.Position);
        return false;
    }

    ref ast3 = ast3\withPos(context.Factory,?,context.Invocation.Position,?);
    var refNode = ast3("Reference",entityref_to(ast3\withPos));
    var astCallNode = ast3("IndirectCall",refNode,SI.get);

    var getFactory;
    var nodePosition;

    if(is_in_macro(context))
    {
        establish_macro_context(context);
        var contextVarRefNode = ast3("Reference",SI.e.lvar(Prexonite::Compiler::MacroAliases.ContextAlias));
        var getContextRef = ast3("IndirectCall",contextVarRefNode,SI.get); // context is passed as a read-only reference (lref), so we need to dereference it twice
        var getContext = ast3("IndirectCall",getContextRef,SI.get);
        
        var getInvComp = ast3("MemberAccess",getContext,"Invocation",SI.get);
        nodePosition = ast3("MemberAccess", getInvComp, "Position", SI.get);

        getFactory = ast3("MemberAccess",getContext,"Factory",SI.get); 
    }
    else
    {
        // getFactory == get_unscoped_ast_factory
        getFactory = ast3("IndirectCall",ast3("Reference",SI.e.cmd(Prexonite::Commands::Core::GetUnscopedAstFactory.Alias)));

        // nodePosition == create_source_position(__FILE__,__LINE__,__COLUMN__)
        nodePosition = ast3("IndirectCall",ast3("Reference",SI.e.cmd(Prexonite::Commands::Core::CreateSourcePosition.Alias)));
        nodePosition.Arguments.Add(ast3("Constant",context.Invocation.Position.File));
        nodePosition.Arguments.Add(ast3("Constant",context.Invocation.Position.Line));
        nodePosition.Arguments.Add(ast3("Constant",context.Invocation.Position.Column));
    }

    astCallNode.Arguments.AddRange([getFactory,type,nodePosition]);
    astCallNode.Arguments.AddRange(var args >> skip(1));

    context.Block.Expression = astCallNode;

    return true;
}

declare: ast3\macro as ast3;

//This macro makes passing `context` to is_in_macro optional (but still possible)
macro is_in_macro(explicitContext)
{
    if(explicitContext is null and not is_in_macro\impl(context))
    {
        context.ReportMessage(Prexonite::Compiler::MessageSeverity.Error, "If is_in_macro is not used inside a macro, the context has to be passed explicitly.", context.Invocation);
        return;
    }
    
    var getContext;
    if(explicitContext is null)
    {
        establish_macro_context(context);
        getContext = ast3("IndirectCall",ast3("IndirectCall",ast3("Reference", SI.e.lvar(Prexonite::Compiler::MacroAliases.ContextAlias)), SI.get), SI.get);
    }
    else
    {
        getContext = explicitContext;
    }
    
    var funcCall = ast3("IndirectCall", ast3("Reference", entityref_to(is_in_macro\impl)), SI.get);
    funcCall.Arguments.Add(getContext);
    return funcCall;
}

macro establish_macro_context()
{
    establish_macro_context\impl(context);
    
    var estCall = ast3("IndirectCall", ast3("Reference", entityref_to(establish_macro_context\impl)), SI.get);
    estCall.Arguments.Add(ast3("IndirectCall", ast3("IndirectCall", ast3("Reference", SI.e.lvar(Prexonite::Compiler::MacroAliases.ContextAlias)), SI.get), SI.get));
    return estCall;
}

macro macro\get_context()
{    
    // `SI.e.lvar(Prexonite::Compiler::MacroAliases.ContextAlias)`
    var getSI = ast3("IndirectCall", ast3("Reference",entityref_to(SI)));
    var getSIEntity = ast3("MemberAccess", getSI, "e");
    var getSIEntityLVar = ast3("MemberAccess", getSIEntity, "lvar");
    getSIEntityLVar.Arguments.Add(ast3("Constant",Prexonite::Compiler::MacroAliases.ContextAlias));

    // `ast3("Reference",SI.e.lvar(Prexonite::Compiler::MacroAliases.ContextAlias))`
    var refCtor = ast3("Expand",entityref_to(ast3));
    refCtor.Arguments.Add(ast3("Constant","Reference"));
    refCtor.Arguments.Add(getSIEntityLVar);

    function dereference(node)
    {
        var ctor = ast3("Expand", entityref_to(ast3));
        ctor.Arguments.Add(ast3("Constant","IndirectCall"));
        ctor.Arguments.Add(node);
        return ctor;
    }   

    // `ast3("IndirectCall",ast3("IndirectCall",ast3("Reference",SI.e.lvar(Prexonite::Compiler::MacroAliases.ContextAlias))))`
    return dereference(dereference(refCtor));
}

function macro\report_any(message, severity)
    [\sharedNames {context}; is compiler;]
{
    var getContext = macro\get_context;
    var parseMessageSeverity_t = ast("ConstantTypeExpression", "Object(\"Prexonite.Compiler.MessageSeverity\")");
    var getSeverity = ast("GetSetStatic", SI.get, parseMessageSeverity_t, severity);
    var getInvocation = ast("GetSetMemberAccess", SI.get, getContext, "Invocation");
    var position = ast("GetSetMemberAccess",SI.get,getInvocation,"Position");
    var reportMessage = ast("GetSetMemberAccess", SI.get, getContext, "ReportMessage");    
    reportMessage.Arguments.Add(getSeverity);
    reportMessage.Arguments.Add(message);
    reportMessage.Arguments.Add(position);
    
    return reportMessage;
}

macro macro\report_error(message)
{
    establish_macro_context;
    
    ref impl = asm( newclo macro\report_any );
    
    return impl(message, "Error");
}

macro macro\report_warning(message)
{
    establish_macro_context;
    
    ref impl = asm( newclo macro\report_any );
    
    return impl(message, "Warning");
}

macro macro\report_info(message)
{
    establish_macro_context;
    
    ref impl = asm( newclo macro\report_any );
    
    return impl(message, "Info");
}

//Returns an AST node that represents an access to SI
macro macro\getSI
{
    if(context.IsJustEffect)
        return;
    
    //  We need to construct the following expression:
    //      `ast3("IndirectCall",ast3("Reference",entityref_to(->SI))`

    // `entityref_to(SI)`
    var SIentityRefNode = ast3("Expand",entityref_to(entityref_to));
    SIentityRefNode.Arguments.Add(ast3("IndirectCall",ast3("Reference",entityref_to(SI))));

    // `ast3("Reference", $SIentityRefNode)`
    var refCtor = ast3("Expand", entityref_to(ast3));
    refCtor.Arguments.Add(ast3("Constant","Reference"));
    refCtor.Arguments.Add(SIentityRefNode);

    // `ast3("IndirectCall",$refCtor)`
    var indirectCallCtor = ast3("Expand",entityref_to(ast3));
    indirectCallCtor.Arguments.Add(ast3("Constant","IndirectCall"));
    indirectCallCtor.Arguments.Add(refCtor);

    context.Block.Expression = indirectCallCtor;
    return;
}

macro tempalloc(getContext)
{
    if(is_in_macro(context))
    {
        establish_macro_context;
    }
    else if(getContext is Null)
    {
        macro\report_error("tempalloc must either be called in a macro context, or be supplied a context~Prexonite::Compiler::CompilerTarget");
        return;
    }
    
    getContext ??= macro\get_context;
    
    return ast("GetSetMemberAccess",SI.get,getContext,"AllocateTemporaryVariable");
}

macro tempfree(getContext, tempId)
{
    if(tempId is Null)
    {
        tempId = getContext;
        getContext = null;
    }
    
    var contextAlias = Prexonite::Compiler::MacroAliases.ContextAlias;
    
    if(is_in_macro)
    {
        establish_macro_context;
    }
    else if(getContext is Null)
    {
        macro\report_error("tempfree must either be called in a macro context, or be supplied a macro context.");
        return;
    }
    
    if(tempId is Null)
    {
        macro\report_error("tempfree must know which temporary variable to free!");
        return;
    }
    
    getContext ??= macro\get_context;
    
    var c = ast("GetSetMemberAccess",SI.get,getContext,"FreeTemporaryVariable");
    c.Arguments.Add(tempId);
    
    return c;
}

//Create node type check functions (to separate macro implementations from the CLR ast node types).
function macro\_expand_into_function(ldr, id, body)[compiler]
{
    //create function meta data and compiler target
    var node_arg = "node_arg";
    var func = ldr.ParentApplication.CreateFunction(id);
    func.Parameters.Add(node_arg);
    func.Meta["compiler"] = true;    
    var target = ldr.CreateFunctionTarget(func,null,null);    
    
    //create function body {return <body>(node_arg, <args...>);}
    var block = target.Ast;
    block.Add(var ret = ast("Return",Prexonite::Compiler::Ast::ReturnVariant.Exit));
    ret.Expression = var bodyMi = ast3("Expand", body);
    bodyMi.Arguments.Add(ast3("IndirectCall", ast3("Reference", SI.e.lvar(node_arg)), SI.get));
    bodyMi.Arguments.AddRange(var args >> skip(3));
    
    //Have the body compiled
    try {
        target.Ast.EmitCode(target, true, Prexonite::Compiler::Ast::StackSemantics.Effect);
        target.FinishTarget();
    } catch(var exc) {
        throw new Prexonite::PrexoniteException("An $(exc.GetType.Name) occurred while expanding the macro $body into $func.");
    }
    
    //Add symbol entry
    ldr.Symbols.Declare(id,SI.s.dereference(SI.s.entity(SI.e.func(func),SI.no_location),SI.no_location));
    return null;
}

function AstNode_t[compiler]
{
    static var field ??= System::Type.GetType("Prexonite.Compiler.Ast.AstNode");
    return field;
}

function create_global_variable\impl(context, id, ref declRef)[compiler]
{
    id ??= uniqueId;
    id ~= String;
    
    var m = context.Application.Module;
    
    //Do not rely on declRef working like a variable, it is likely a null value.
    declRef = var decl = if(m.Variables.Contains(id)) 
                    m.Variables[id] 
               else 
                    (m.Variables.Add = Prexonite::Modular::VariableDeclaration.Create(id));
                    
    var a = context.Application;
    var pvar = if(a.Variables.ContainsKey(id))
                    a.Variables[id]
               else
                    (a.Variables.Add(id) = new Prexonite::PVariable(decl));
                    
    return pvar;
}

macro create_global_variable\macro as create_global_variable(id, declRef)[partial\macro]
{
    // TODO: make create_global_variable available to build block code.
    establish_macro_context;
    
    context.Block.Expression = var implCall = ast3("IndirectCall", ast3("Reference", entityref_to(create_global_variable\impl)), context.Call);
    implCall.Arguments.Add(macro\get_context);
    implCall.Arguments.AddRange(var args);
    
    return true;
}

macro macro\_check_is_node_t(node_arg,node_t_name,requirePlaceholder,requireAstNode)
{
    function create_node_arg(c)
    {
        var r = node_arg.GetCopy();
        if(c is not null)
            r.Call = c;
        return r;
    }
    
    var requirePlaceholder = if(requirePlaceholder is not null) requirePlaceholder.Constant~Bool else false;
    var requireAstNode = if(requireAstNode is not null) requireAstNode.Constant~Bool else false;

    // //Ensure is object type in the first place
    var arg_pt = tempalloc;
    function create_arg_pt(c) = ast3("IndirectCall", ast3("Reference",SI.e.lvar(arg_pt)), c ?? SI.get);
    
    var node_t = uniqueId(id + @"\node_t");
    function create_node_t(c) = ast3("IndirectCall", ast3("Reference", SI.e.gvar(node_t, macro\macro_pxs_module)), c ?? SI.get);
    
    var node_t_var = new global_variable(node_t);
    node_t_var.Meta["compiler"] = true;
    
    // if((var arg_pt = boxed(node_arg).Type) is not Prexonite::Types::ObjectPType)
        // return false;
    {
        var box_node_arg = ast3("IndirectCall", ast3("Reference", entityref_to(boxed)), SI.get);
        box_node_arg.Arguments.Add(new node_arg);
        var set_arg_pt = new arg_pt(SI.set);
        set_arg_pt.Arguments.Add(ast("GetSetMemberAccess", box_node_arg, "Type"));

        var obj_type_check = ast("TypeCheck",set_arg_pt,ast("ConstantTypeExpression",
            "Object(\"Prexonite.Types.ObjectPType\")"));

        var cond = ast3("Condition",obj_type_check,true);
        cond.IfBlock.Add(var ret_false = ast("Return",Prexonite::Compiler::Ast::ReturnVariant.Exit));
        ret_false.Expression = ast("Constant",false);
        
        context.Block.Add(cond);
    }
    
    // static var node_t ??= System::Type.GetType(node_t_name);
    {
        var node_t_null_check = ast("TypeCheck", new node_t, ast("ConstantTypeExpression","Null"));
        var cond = ast3("Condition", node_t_null_check,false);
        var type_getType = ast("GetSetStatic", SI.get, 
            ast("ConstantTypeExpression", "Object(\"System.Type\")"), "GetType");
        type_getType.Arguments.Add(node_t_name);
        var set_node_t = new node_t(SI.set);
        set_node_t.Arguments.Add(type_getType);
        cond.IfBlock.Add(set_node_t);
        
        context.Block.Add(cond);
    }
    
    // //Check if it is correct node, but not a partial application
    // return node_t.IsAssignableFrom(arg_pt.ClrType) and not node_arg.CheckForPlaceholders();
    {
        
        var assignable = ast("GetSetMemberAccess",new node_t,"IsAssignableFrom");
        assignable.Arguments.Add(ast("GetSetMemberAccess", new arg_pt, "ClrType"));
        
        var has_placeholders = ast("GetSetMemberAccess", new node_arg, "CheckForPlaceholders");
        
        if(not requirePlaceholder)
        {
            var has_placeholders = ast3("UnaryOperation",Prexonite::Compiler::Ast::UnaryOperator.LogicalNot,
                has_placeholders,SI.cmd(~Object<"Prexonite.OperatorNames+Prexonite">.LogicalNot));
        }
        
        var conjunction;
        
        if(not requireAstNode)
        {
            conjunction = ast("LogicalAnd",assignable,has_placeholders);
        }
        else
        {
            var assignableAstNode = ast("GetSetMemberAccess", ast3("IndirectCall", ast3("Reference", entityref_to(AstNode_t)), SI.get),
                "IsAssignableFrom");
            assignableAstNode.Arguments.Add(ast("GetSetMemberAccess", new arg_pt, "ClrType"));
            
            conjunction = ast("LogicalAnd", assignableAstNode, assignable);
            conjunction.AddExpression(has_placeholders);
        }
        
        context.Block.Expression = conjunction;
    }
    return;
}

build
{
    function human_name(t) = if((var n = t.Name).StartsWith("Ast")) n.Substring(3) else n;
    
    //Create check function for each type that inherits from AstNode
    AstNode_t.Assembly.GetTypes() 
    >> where(AstNode_t.IsAssignableFrom(?))
    >> var node_ts;
    
    var impl = SI.e.func(asm(ldr.app).Functions[@"macro\_check_is_node_t"]);
    
    foreach(new var node_t in node_ts)
    {
        var ref_name = "ast_is_$(human_name(node_t))";
        
        //create function, pass full name of type to check against
        macro\_expand_into_function(GetLoader,
            ref_name, //Id of the generated function
            impl, //id of the macro that provides the implementation
            ast("Constant",node_t.FullName), //name of the type to check against
        );
        
        //create function for partial applications of these types
        macro\_expand_into_function(GetLoader,
            "ast_is_partial_$(human_name(node_t))", //id of the generate function
            impl, //id of the macro that provides the implementation
            ast("Constant",node_t.FullName), //name of the type to check against
            ast("Constant",true), //true ↔ reject nodes *without* placeholders
        );
    }
    
    //Create special check functions for expressions, partially applicables and effects
    var interfaces = ["Prexonite.Compiler.Ast.AstExpr": "ast_is_expression",
                      "Prexonite.Compiler.Ast.IAstPartiallyApplicable": "ast_is_partially_applicable"];
    foreach(var entry in interfaces)
    {
        macro\_expand_into_function(GetLoader,
            entry.Value, //id of the generated function
            impl, //id of the macro that provides the implementation
            ast("Constant",entry.Key), //name of the type to check against
            ast("Constant",false), //false ↔ reject nodes with placeholders
            ast("Constant",true),  //require explicit check against AstNode_t
        );
    }
    
    //Create special check function for partial application (any)
    macro\_expand_into_function(GetLoader,
        "ast_is_partial_application", //id of the generated function
        impl, //id of the macro that provides the implementation
        ast("Constant",AstNode_t.FullName), //name of the type to check against
        ast("Constant",true), //true ↔ reject nodes *without* placeholders
    );
    
    //Remove helper functions
    GetLoader.ParentApplication.Functions.Remove(->human_name.Id);
}

function ast_is_effect(n) = ast_is_Node(n);
function ast_is_something_obsolete as ast_is_MacroInvocation, ast_is_GetSetSymbol, ast_is_GetSetReference(_)[\sps] = false;

declare(
    ast_is_MacroInvocation = warn(pos("macro.pxs",607,0),"PSR.Obsolete",@"MacroInvocation nodes no longer exist. Use Expand instead.",sym "ast_is_MacroInvocation"),
    ast_is_GetSetSymbol = warn(pos("macro.pxs",608,0),"PSR.Obsolete",@"GetSetSymbol nodes no longer exist. Use IndirectCall of Reference instead.",sym "ast_is_GetSetSymbol"),
    ast_is_GetSetReference = warn(pos("macro.pxs",609,0),"PSR.Obsolete",@"GetSetReference nodes no longer exist. Use Reference instead.",sym "ast_is_GetSetReference")
);

//Optimization
function optimize\ref(context, ref node) [is compiler;]
{
    return node = context.GetOptimizedNode(node);
}

macro optimize(contextRef, node)
{
    var skipCount;
    if(node is Null)
    {
        node = contextRef;
        contextRef = null;
        skipCount = 0;
    }
    else
    {
        skipCount = 1;
    }
    
    if(is_in_macro)
    {
        establish_macro_context;
        contextRef ??= macro\get_context;
    }
    else if(contextRef is Null)
    {
        macro\report_error("optimize(context, node) requires a macro context.");
        return;
    }
    
    if(node is Null)
    {
        macro\report_error("optimize([context, ] node) requires a node to optimize");
        return;
    }
    
    if(ast_is_GetSet(node))
    {
        var setNode = node.GetCopy();
        setNode.Call = SI.set;
        
        var optCall = ast("GetSetMemberAccess",SI.get,contextRef,"GetOptimizedNode");
        optCall.Arguments.Add(node);        
        setNode.Arguments.Add(optCall);
        
        return setNode;
    }
    else 
    {
        var funCall = ast3("IndirectCall",ast3("Reference",SI.e.func(->optimize\ref)));
        funCall.Arguments.Add(contextRef);
        funCall.Arguments.AddRange(var args >> skip(skipCount) >> all);
        return funCall;
    }
}

//Safe "evaluation" of constant arguments
function ast\read\impl(context, expr) [is compiler;]
{
    if(context is not Prexonite::Compiler::Macro::MacroContext)
        throw "Context cannot be set for ast\\read.";
    
    if(expr is Null)
        return null;
        
    //Apply optimization to get constant folding
    optimize(context, expr);
    
    function convert(subexpr)
    {        
        if(subexpr is Prexonite::Compiler::Ast::AstConstant)
            return subexpr.Constant;
        else if(subexpr is Prexonite::Compiler::Ast::AstListLiteral)
            return subexpr.Elements >> map(convert(?)) >> all;
        else if(subexpr is Prexonite::Compiler::Ast::AstHashLiteral)
            return subexpr.Elements >> map(convert(?)) >> all;
        else if(subexpr is Prexonite::Compiler::Ast::AstKeyValuePair)
            return convert(subexpr.Key) : convert(subexpr.Value);
        else if(subexpr is Prexonite::Compiler::Ast::AstNull)
            return null;
        else 
            throw "Cannot convert compile-time expression $(boxed(expr)) to runtime value.";
    }
    
    return convert(expr);
}

macro ast\read\macro as ast\read(contextRef, expr)[\sps;partial\macro]
{
    if(expr is null)
    {
        expr = contextRef;
        contextRef = null;
    }
    
    if(expr is null)
    {
        macro\report_error("ast\\read requires a constant expression to read.");
        return false;
    }

    if(contextRef is null and not is_in_macro)
    {
        macro\report_error("ast\\read must either be used as part of another macro or be provided a macro context (as its first argument).");
        return false;
    }
    
    if(contextRef is null)
    {
        establish_macro_context;
        contextRef = macro\get_context;
    }
    
    var fcall = context.Block.Expression = ast3("IndirectCall",ast3("Reference",entityref_to(ast\read\impl)),context.Call);
    fcall.Arguments.Add(contextRef);
    fcall.Arguments.Add(expr);
    return true;
}

function macro\_extract_id(prototype)[is compiler;]
{
    if(prototype is Prexonite::Compiler::Ast::AstExpand)
        return prototype.Entity.Id;
    else
        return prototype.Subject.Entity.Id;
}

macro macro\id(prototype)
{
    if(context.IsJustEffect)
        return;
    
    var sym = prototype.Implementation.Interpretation;
    
    if(SI.is_func(sym) or SI.is_gvar(sym) or SI.is_gref(sym))
        macro\report_warning("The value returned by macro\\id is not sufficient to identify a macro, even in conjunction with macro\\interpretation. Either use macro\\internal_id to avoid this warning, or get the symbol entry corresponding to the macro via macro\\symbol.");
        
    return ast("Constant",macro\_extract_id(prototype));
}

macro macro\internal_id(prototype)
{
    if(context.IsJustEffect)
        return;
    return ast("Constant",macro\_extract_id(prototype));
}

macro macro\interpretation(prototype)
{
    if(context.IsJustEffect)
        return;
    
    declare: macro\getSI as getSI;
    
    var siMem;
    if(ast_is_MacroInvocation(prototype))
    {
        macro\report_error("MacroInvocation no longer exists.");
        return;
    }
    else if(ast_is_GetSetSymbol(prototype))
    {
        var i = prototype.Implementation.Interpretation;
        if(SI.is_lvar(i))
            siMem = "lvar";
        else if(SI.is_lref(i))
            siMem = "lref";
        else if(SI.is_gvar(i))
            siMem = "gvar";
        else if(SI.is_gref(i))
            siMem = "gref";
        else if(SI.is_func(i))
            siMem = "func";
        else if(SI.is_cmd(i))
            siMem = "cmd";
        else if(SI.is_mcmd(i))
            siMem = "mcmd";
        else {
            macro\report_error("Unkown symbol interpretation $i. Assuming function");
            siMem = "func";
        }
        
        var getSI\i = ast("GetSetMemberAccess",SI.get,getSI,siMem);
        
        return getSI\i;
    }
    else
    {
        return ast("Null");
    }
}

// Converts `macro\entity(someCall)` into an expression that represents the entity "someCall" (an EntityRef).
declare(
    macro\entity = warn(here,"PSR.Obsolete",@"macro\entity is a backwards-compatibility alias to entityref_to. Use that instead.",sym "entityref_to"),
    macro\symbol = error(here,"PSR.Obsolete",@"macro\symbol is deprecated. Use entityref_to instead.",null),
    ast\symbol = error(here,"PSR.Obsolete",@"ast\symbol is deprecated. Use EntityRef instead.",null),
    ast\invoke_macro = error(pos("macro.pxs",978,0),"PSR.Obsolete",@"ast\invoke_macro is obsolete. Use ast\expand_macro(macro\entity(yourMacro)) instead.",null)
);

macro ast\null
{
    if(context.IsJustEffect) 
        return;
    
    var ctor = ast3("Expand",entityref_to(ast3));
    ctor.Arguments.Add(ast3("Constant","Null"));
    context.Block.Expression = ctor;
    return;
}

macro ast\expand_macro(entity,callType)
{
    if(context.IsJustEffect)
        return;
        
    if(is_in_macro)
        establish_macro_context;

    if(entity is null)
    {
        macro\report_error("ast\\expand_macro requires at least one argument. Usage: ast\\expand_macro(entity) or ast\\expand_macro(macro\\entity(prototype))");
        return null;
    }

    var c = ast3("Expand",macro\entity(ast3\macro),context.Call);
    c.Arguments.Add(ast3("Constant","Expand"));

    c.Arguments.Add(entity);
    c.Arguments.Add(callType ?? ast3("MemberAccess",macro\getSI,"get",SI.get));

    context.Block.Expression = c;
    return;
}

macro ast\call(callTypeExpr,entityExpr)
{
    if(context.IsJustEffect)
        return;

    if(is_in_macro)
        establish_macro_context;

    if(entityExpr is null)
    {
        entityExpr = callTypeExpr;
        callTypeExpr = ast3("MemberAccess",macro\getSI,"get");
    }

    if(entityExpr is null)
    {
        macro\report_error(@"ast\call([callTypeExpr,] entityExpr) required at least one argument, the entity expression.");
        return;
    }

    // ast3("IndirectCall",ast3("Reference",$(entity)),$(callType));

    var referenceCtor = ast\expand_macro(entityref_to(ast3));
    referenceCtor.Arguments.Add(ast3("Constant","Reference"));
    referenceCtor.Arguments.Add(entityExpr);

    var indirectCallCtor = ast\expand_macro(entityref_to(ast3));
    indirectCallCtor.Arguments.Add(ast3("Constant","IndirectCall"));
    indirectCallCtor.Arguments.Add(referenceCtor);
    indirectCallCtor.Arguments.Add(callTypeExpr);
    
    context.Block.Expression = indirectCallCtor;
    return;
}

macro ast\cmd(callType,id)
{
    if(context.IsJustEffect)
        return;

    if(id is null)
    {
        id = callType;
        callType = ast3("MemberAccess",macro\getSI,"get");
    }

    if(callType is null or id is null)
    {
        macro\report_error(@"ast\cmd requires at least two arguments: ast\cmd(callType,commandId)");
        return;
    }

    if(is_in_macro)
        establish_macro_context;

    // `SI.e.cmd(id)`
    var entityMode = ast3("MemberAccess",macro\getSI,"e");
    var entityExpr = ast3("MemberAccess",entityMode,"cmd");
    entityExpr.Arguments.Add(id);

    var callExpansion = ast\expand_macro(macro\entity(ast\call));
    callExpansion.Arguments.Add(callType);
    callExpansion.Arguments.Add(entityExpr);

    context.Block.Expression = callExpansion;
    return;
}

macro ast\lvar(callType,id)
{
    if(context.IsJustEffect)
        return;

    if(id is null)
    {
        id = callType;
        callType = ast3("MemberAccess",macro\getSI,"get");
    }

    if(callType is null or id is null)
    {
        macro\report_error(@"ast\lvar requires at least two arguments: ast\lvar(callType,variableId)");
        return;
    }

    if(is_in_macro)
        establish_macro_context;

    // `SI.e.lvar(id)`
    var entityMode = ast3("MemberAccess",macro\getSI,"e");
    var entityExpr = ast3("MemberAccess",entityMode,"lvar");
    entityExpr.Arguments.Add(id);

    var callExpansion = ast\expand_macro(macro\entity(ast\call));
    callExpansion.Arguments.Add(callType);
    callExpansion.Arguments.Add(entityExpr);

    context.Block.Expression = callExpansion;
    return;
}

macro ast\lref(callType,id)
{
    if(context.IsJustEffect)
        return;

    if(id is null)
    {
        id = callType;
        callType = ast3("MemberAccess",macro\getSI,"get");
    }

    if(callType is null or id is null)
    {
        macro\report_error(@"ast\lref requires at least two arguments: ast\lref(callType,variableId)");
        return;
    }

    if(is_in_macro)
        establish_macro_context;

    // `SI.get` or `SI.set`
    var getCall = ast3("MemberAccess",macro\getSI,"get");

    // `SI.e.lvar(id)`
    var entityMode = ast3("MemberAccess",macro\getSI,"e");
    var entityExpr = ast3("MemberAccess",entityMode,"lvar");
    entityExpr.Arguments.Add(id);

    var callExpansion = ast\expand_macro(macro\entity(ast\call));
    callExpansion.Arguments.Add(getCall);
    callExpansion.Arguments.Add(entityExpr);

    // `ast3("IndirectCall",callExpansion,$callType)`
    var indirectCallCtor = ast\expand_macro(macro\entity(ast3));
    indirectCallCtor.Arguments.Add(ast3("Constant","IndirectCall"));
    indirectCallCtor.Arguments.Add(callExpansion);
    indirectCallCtor.Arguments.Add(callType);

    context.Block.Expression = indirectCallCtor;
    return;
}

macro ast\func(callType,internalId,moduleName)
{
    if(context.IsJustEffect)
        return;

    if(moduleName is null)
    {
        moduleName = internalId;
        internalId = callType;
        callType = ast3("MemberAccess",macro\getSI,"get");
    }

    if(callType is null or internalId is null)
    {
        macro\report_error(@"ast\func requires at least two arguments: ast\func(callType,internalId,moduleName) or ast\func(callType,funcRef).");
        return;
    }

    if(is_in_macro)
        establish_macro_context;

    // `SI.e.func(internalId,moduleName)`
    var entityMode = ast3("MemberAccess",macro\getSI,"e");
    var entityExpr = ast3("MemberAccess",entityMode,"func");
    entityExpr.Arguments.Add(internalId);
    if(moduleName is not null) // module name can be null if internalId is really a PFunction reference.
                               // In that case, SI.e.func will infer the module name from the function reference.
        entityExpr.Arguments.Add(moduleName);

    var callExpansion = ast\expand_macro(macro\entity(ast\call));
    callExpansion.Arguments.Add(callType);
    callExpansion.Arguments.Add(entityExpr);

    context.Block.Expression = callExpansion;
    return;
}

macro ast\gvar(callType,internalId,moduleName)
{
    if(context.IsJustEffect)
        return;

    if(moduleName is null)
    {
        moduleName = internalId;
        internalId = callType;
        callType = ast3("MemberAccess",macro\getSI,"get");
    }

    if(callType is null or internalId is null or moduleName is null)
    {
        macro\report_error(@"ast\gvar requires at least three arguments: ast\gvar(callType,internalId,moduleName).");
        return;
    }

    if(is_in_macro)
        establish_macro_context;

    // `SI.e.func(internalId,moduleName)`
    var entityMode = ast3("MemberAccess",macro\getSI,"e");
    var entityExpr = ast3("MemberAccess",entityMode,"gvar");
    entityExpr.Arguments.Add(internalId);
    entityExpr.Arguments.Add(moduleName);

    var callExpansion = ast\expand_macro(macro\entity(ast\call));
    callExpansion.Arguments.Add(callType);
    callExpansion.Arguments.Add(entityExpr);

    context.Block.Expression = callExpansion;
    return;
}

macro ast\gref(callType,internalId,moduleName)
{
    if(context.IsJustEffect)
        return;

    if(moduleName is null)
    {
        moduleName = internalId;
        internalId = callType;
        callType = ast3("MemberAccess",macro\getSI,"get");
    }

    if(callType is null or internalId is null or moduleName is null)
    {
        macro\report_error(@"ast\gref requires at least three arguments: ast\gref(callType,internalId,moduleName).");
        return;
    }

    if(is_in_macro)
        establish_macro_context;

    // `SI.get`
    var getCall = ast3("MemberAccess",macro\getSI,"get");

    // `SI.e.func(internalId,moduleName)`
    var entityMode = ast3("MemberAccess",macro\getSI,"e");
    var entityExpr = ast3("MemberAccess",entityMode,"gvar");
    entityExpr.Arguments.Add(internalId);
    entityExpr.Arguments.Add(moduleName);

    var callExpansion = ast\expand_macro(macro\entity(ast\call));
    callExpansion.Arguments.Add(getCall);
    callExpansion.Arguments.Add(entityExpr);

    // `ast3("IndirectCall",callExpansion,$callType)`
    var indirectCallCtor = ast\expand_macro(macro\entity(ast3));
    indirectCallCtor.Arguments.Add(ast3("Constant","IndirectCall"));
    indirectCallCtor.Arguments.Add(callExpansion);
    indirectCallCtor.Arguments.Add(callType);

    context.Block.Expression = indirectCallCtor;
    return;
}
//Create GetSetMemberAccess node
macro ast\member(subject, call_type, id)
{
    if(id is Null)
    {
        id = call_type;
        call_type = null;
    }
    
    if(is_in_macro)
        establish_macro_context;
    
    id ??= ast("Constant","");
    call_type ??= ast("GetSetMemberAccess",SI.get,macro\getSI,"get");
    
    var c = ast\expand_macro(macro\entity(ast\macro));
    c.Arguments.Add(ast("Constant","GetSetMemberAccess"));
    c.Arguments.Add(call_type);
    c.Arguments.Add(subject);
    c.Arguments.Add(id);
    
    return c;
}

function ast\const\dynamic(value) [is compiler;]
{
    if(value is Null)
    {
        return ast("Null");
    }
    else if(value is Int or value is Real or value is Bool or value is String)
    {
        return ast("Constant",value);
    }
    else if(value is List)
    {
        var lst = ast("ListLiteral");
        foreach(var v in value)
            lst.Elements.Add(ast\const\dynamic(v));
        return lst;
    }
    else if(value is Prexonite::Types::PValueKeyValuePair)
    {
        var kvp = ast("KeyValuePair", ast\const\dynamic(value.Key), ast\const\dynamic(value.Value));
        return kvp;
    }
    else
    {
        throw "Cannot represent runtime value $(value.\boxed) as compile-time value.";
    }
}

macro ast\const(value)
[ Add Prexonite::Compiler::Ast to Imports;]
{   
    if(value is null)
    {
        macro\report_error(@"ast\const(valueExpr) requires at least one argument.");
        return;
    }

    if(is_in_macro)
        establish_macro_context;
 
    if(ast_is_Null(value) or (ast_is_Constant(value) and value.Constant is null))
    {
        var c = ast\expand_macro(macro\entity(ast\macro));
        c.Arguments.Add(ast3("Constant","Null"));
        return c;
    }
    else if(ast_is_Constant(value))
    {
        var c = ast\expand_macro(macro\entity(ast\macro));
        c.Arguments.Add(ast3("Constant","Constant"));
        c.Arguments.Add(value);
        return c;
    }
    else if(ast_is_KeyValuePair(value))
    {
        var kvp = ast\expand_macro(macro\entity(ast\macro));
        kvp.Arguments.Add(ast("Constant","KeyValuePair"));
        kvp.Arguments.Add(call\macro([ast\const(value.Key)]));
        kvp.Arguments.Add(call\macro([ast\const(value.Value)]));
        return kvp;
    }
    else
    {
        var c = ast\call(SI.get, macro\entity(ast\const\dynamic));
        c.Arguments.Add(value);
        return c;        
    }
}

//Create return nodes
macro ast\ret\generic_proc(expr, kind)
{   
    if(is_in_macro)
        establish_macro_context;
 
    var mkRetNode = ast\expand_macro(macro\entity(ast\macro));
    mkRetNode.Arguments.Add(ast\const("Return"));
    mkRetNode.Arguments.Add(ast\member(macro\getSI, SI.get, "ret\\$kind"));
    if(expr is Null)
    {
        if(kind.ToLowerInvariant == "set")
        {
            macro\report_error("Set return requires an expression.");
            return;
        }
        else
        {
            context.Block.Expression = mkRetNode;
            return;
        }
    }
    else
    {
        var vr = tempalloc;
        
        //store ret node in variable r
        var setR = ast\lvar(SI.set, vr);
        setR.Arguments.Add(mkRetNode);
        context.Block.Add(setR);
        
        //assign expr to r.Expression
        var setE = ast\member(ast\lvar(SI.get, vr), SI.set, "Expression");
        setE.Arguments.Add(expr);
        context.Block.Add(setE);
        
        context.Block.Expression = ast\lvar(SI.get, vr);
        
        tempfree(vr);
        return;
    } 
}

macro ast\ret\val as ast\ret(expr)
{
    return asm(newclo ast\ret\generic_proc).(expr,"exit");
}

macro ast\ret\continue as ast\yield(expr)
{
    return asm(newclo ast\ret\generic_proc).(expr,"continue");
}

macro ast\ret\break(expr)
{
    return asm(newclo ast\ret\generic_proc).(expr,"break");
}

macro ast\ret\set(expr)
{
    return asm(newclo ast\ret\generic_proc).(expr,"set");
}

//Evaluate Ast nodes (really executing them, so watch out!)
function ast\run\impl(loader, block) [is compiler;]
{
    if(loader is null)
        throw @"ast\run(loader,block) requires a reference to a loader.";
    if(block is null)
        throw @"ast\run(loader,block) requires a non-null root block.";

    var func = new Prexonite::PFunction(loader.ParentApplication);
    var funcTarget = loader.CreateFunctionTarget(func, block);
    funcTarget.Ast.EmitCode(funcTarget, true, Prexonite::Compiler::Ast::StackSemantics.Effect);
    funcTarget.FinishTarget();
    var result = func.();
    loader.FunctionTargets.Remove(funcTarget);
    loader.ParentApplication.Functions.Remove(func);
    return result;
}

macro ast\run(loaderRef, block)
{
    if(block is Null)
    {
        block = loaderRef;
        loaderRef = null;
    }
    
    if(is_in_macro)
    {
        establish_macro_context;
    }
    
    if(loaderRef is Null)
    {
        macro\report_error(@"ast\run(loader,block) must be supplied a loader~Prexonite::Compiler::Loader.");
        return;
    }
    if(block is Null)
    {
        macro\report_error(@"ast\run(loader,block) must be supplied a block~Prexonite::Compiler::Ast::AstBlock.");
        return;
    }
    
    var c = ast\call(SI.get, macro\entity(ast\run\impl));
    c.Arguments.Add(loaderRef);
    c.Arguments.Add(block);
    
    return c;
}

function ast\eval\impl(loader, expr) [is compiler;]
{
    if(loader is null)
        throw @"ast\eval(loader,expr) requires a reference to a loader.";
    if(expr is null)
        throw @"ast\eval(loader,expr) requires a non-null expression.";

    // This block will be the root block of a function.
    // The AST factory API does not support construction of root blocks, 
    //    since that is not something that an ordinary macro does.
    var block = Prexonite::Compielr::Ast::AstBlock.CreateRootBlock(
        expr.Position,
        Prexonite::Compiler::Symbolic::SymbolStore.Create(loader.Symbols,null),
        "Block",
        System::Guid.NewGuid().ToString("N"));
    block.Add(ast\ret(expr));
    return ast\run(loader, block);
}

macro ast\eval(loaderRef, expr)
{
    if(expr is Null)
    {
        expr = loaderRef;
        loaderRef = null;
    }
    
    if(is_in_macro)
    {
        establish_macro_context;
    }
    else if(loaderRef is Null)
    {
        macro\report_error(
            @"ast\eval must be supplied a loader~::Loader");
        return;
    }
    
    var c = ast\call(SI.get, macro\entity(ast\eval\impl));
    c.Arguments.Add(loaderRef);
    c.Arguments.Add(expr);
    
    return c;
}

//Abbreviation for ast nodes with arguments
macro ast\with_arguments as ast\args (astN)
{
    var args;
    if(args.Count < 1)
        macro\report_error("ast\\with_arguments requires at least one argument, the node to add arguments to.");
    
    if(args.Count == 1)
        return astN;

    var astV = tempalloc;
    
    var assignAst = ast\lvar(SI.set, astV);
    assignAst.Arguments.Add(astN);
    context.Block.Add(assignAst);
    
    
    if(args.Count > 1)
    {
        ref getArguments;
        var argumentsV;
        var assignAst;
        if(args.Count > 2)
        {      
            var getArguments = ast\member(ast\lvar(SI.get, astV), SI.get, "Arguments");
            argumentsV = tempalloc;
            assignAst = ast\lvar(SI.set, argumentsV);
            assignAst.Arguments.Add(getArguments);
            context.Block.Add(assignAst);
            
            function getArguments = ast\lvar(SI.get, argumentsV);
        }
        else
        {
            function getArguments = ast\member(ast\lvar(SI.get, astV), SI.get, "Arguments");
        }
        
        foreach(var argN in var args >> skip(1))
        {
            var assignAst = ast\member(getArguments, SI.get, "Add");
            assignAst.Arguments.Add(argN);
            context.Block.Add(assignAst);
        }
        
        if(argumentsV is not null)
            tempfree(argumentsV);
    }
    
    context.Block.Expression = ast\lvar(SI.get, astV);
    tempfree(astV);
    return;
}

//Object creation (simple, constant type expressions)
macro ast\new\const as ast\new(typename)
{   
    if(is_in_macro)
        establish_macro_context;
    
    var constructV = tempalloc;
    
    //Create object creation node { $constructV = new ObjectCreation(new ConstantTypeExpression($typename)) }   
    context.Block.Add(ast\args(ast\lvar(SI.set, constructV),
        ast\args(ast\expand_macro(macro\entity(ast)),
            ast\const("ObjectCreation"),
            ast\args(ast\expand_macro(macro\entity(ast)),
                ast\const("ConstantTypeExpression"),
                typename
            )
        )
    ));
    
    //Add constructor arguments to constructor nodes
    var args;
    if(args.Count > 1)
    {
        var argsV = tempalloc;
        var getConstruct = ast\lvar(SI.get, constructV);
        var getArguments = ast\member(getConstruct, SI.get, "Arguments");
        var assignArgs = ast\lvar(SI.set, argsV);
        assignArgs.Arguments.Add(getArguments);
        context.Block.add(assignArgs);
        function getArguments = ast\lvar(SI.get, argsV); 
        
        foreach(var argN in var args >> skip(1))
        {
            var addArgument = ast\member(getArguments, SI.get, "Add");
            addArgument.Arguments.Add(argN);
            context.Block.Add(addArgument);
        }
        
        tempfree(argsV);
    }
    
    //return object creation node
    context.Block.Expression = ast\lvar(SI.get, constructV);
    tempfree(constructV);

    return;
}

//Aliases for old macro environment variables that are still compatible with the new system
macro macro\deprecated\newvar as newvar
{
    if(is_in_macro)
    {
        macro\report_error("The macro environment variable `newvar` is no longer supported. Use `tempalloc` instead (if you need the variable to be non-temporary, just don't free it at the end).");
        return;
    }
    else
    {
        var unr = ast("Unresolved", "newvar");
        unr.Call = context.Call;
        return unr;
    }
}

macro macro\deprecated\loader as loader
{
    if(is_in_macro)
    {
        macro\report_error("The macro environment variable `loader` is no longer supported. Code that uses the loader directly, needs to be placed in build blocks. There you can use `getLoader` to get a reference to the loader.");
        return;
    }
    else
    {
        var unr = ast("Unresolved", "loader");
        unr.Call = context.Call;
        return unr;
    }
}

macro macro\deprecated\target as target
{
    if(is_in_macro)
    {
        macro\report_error("The macro environment variable `target` is no longer supported. Code that uses the compiler target directly, needs to be placed in build blocks. There you can use `getLoader` to get a reference to the loader, which in turn references the individual compiler targets.");
        return;
    }
    else
    {
        var unr = ast("Unresolved", "target");
        unr.Call = context.Call;
        return unr;
    }
}

macro macro\deprecated\locals as locals
{
    if(not is_in_macro)
    {
        var unr = ast("Unresolved", "locals");
        unr.Call = context.Call;
        return unr;
    }
    
    macro\report_warning("The macro environment variable `locals` is deprecated. Access local variable information via the `context` variable instead.");
    
    establish_macro_context;
    
    var getContext = ast\lref(SI.get, Prexonite::Compiler::MacroAliases.ContextAlias);
    var getFunction = ast\member(getContext,SI.get,"Function");
    return ast\member(getFunction, SI.get, "Variables");
}

macro macro\deprecated\callType as callType
{
    if(not is_in_macro)
    {
        var unr = ast("Unresolved", "callType");
        unr.Call = context.Call;
        return unr;
    }
    
    macro\report_warning("The macro environment variable `callType` is deprecated. Access the call type via  `context.Call` instead.");
    
    establish_macro_context;
    
    var getContext = ast\lref(SI.get, Prexonite::Compiler::MacroAliases.ContextAlias);
    return ast\member(getContext, SI.get, "Call");
}

macro macro\deprecated\justEffect as justEffect
{
    if(not is_in_macro)
    {
        var unr = ast("Unresolved", "justEffect");
        unr.Call = context.Call;
        return unr;
    }
    
    macro\report_warning("The macro environment variable `justEffect` is deprecated. Access this information via  `context.IsJustEffect` instead.");
    
    establish_macro_context;
    
    var getContext = ast\lref(SI.get, Prexonite::Compiler::MacroAliases.ContextAlias);
    return ast\member(getContext, SI.get, "IsJustEffect");
}

macro macro\deprecated\macroInvocation as macroInvocation
{
    if(not is_in_macro)
    {
        var unr = ast("Unresolved", "macroInvocation");
        unr.Call = context.Call;
        return unr;
    }
    
    macro\report_warning("The macro environment variable `macroInvocation` is deprecated. Access the reference to the macro invocation via `context.Invocation` instead.");
    
    establish_macro_context;
    
    var getContext = ast\lref(SI.get, Prexonite::Compiler::MacroAliases.ContextAlias);
    return ast\member(getContext, SI.get, "Invocation");
}

function ast_is_Call as is_ast_Call(node)
{
    return ast_is_IndirectCall(node) and ast_is_Reference(node.Subject);
}

//Position report
macro __FILE__ as CURRENT_FILE
{
    return ast("Constant",context.Invocation.File);
}

macro __LINE__ as CURRENT_LINE
{
    return ast("Constant",context.Invocation.Line);
}

macro __COLUMN__ as CURRENT_COLUMN, __COL__
{
    return ast("Constant",context.Invocation.Column);
}

macro __POSITION__ as POSITION, __POS__
{
    var file = System::IO::Path.GetFileName(context.Invocation.File);
    var line = context.Invocation.Line;
    var col = context.Invocation.Column;
    return ast\const("$file, line $line, column $col");
}

macro compile_macros\macro as compile_macros()
{
    var c = ast\cmd(SI.get, Prexonite::Engine.CompileToCilAlias);
    c.Arguments.Add(ast\const(false));
    return c;
}
