<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Exception_StreamSource_CannotUseWriteOnlyStream" xml:space="preserve">
    <value>A stream that is not readable cannot be used as a source.</value>
  </data>
  <data name="MetaEntry_NullReferenceInList" xml:space="preserve">
    <value>A MetaEntry list must not contain null references.</value>
  </data>
  <data name="ConflictUnionFallbackStore__unifySymbols_Invalid_key_in_source_for_symbol_store_" xml:space="preserve">
    <value>Invalid key in source for symbol store.</value>
  </data>
  <data name="SymbolEntryConversion_MessageSymbol_cannot_be_converted_to_SymbolEntry" xml:space="preserve">
    <value>Message symbol was not handled before conversion to a legacy SymbolEntry</value>
  </data>
  <data name="SymbolEntryConversion_No_arbirtrary_dereference" xml:space="preserve">
    <value>Legacy symbol entry cannot express arbitrary dereference symbol modifiers.</value>
  </data>
  <data name="SymbolEntryConversion_MacroInstance_not_supported" xml:space="preserve">
    <value>Cannot convert a macro instance symbol to a legacy SymbolEntry.</value>
  </data>
  <data name="Loader__begin_compiling" xml:space="preserve">
    <value>{1}begin compiling {0} [Path: {2} ]</value>
  </data>
  <data name="Loader__end_compiling" xml:space="preserve">
    <value>{1}end   compiling {0}</value>
  </data>
  <data name="CompilerTarget_Cannot_create_for_foreign_function" xml:space="preserve">
    <value>When creating a compiler target, the supplied function must match the application targetted by the loader.</value>
  </data>
  <data name="AstNode__GetOptimizedNode_CompilerTarget_null" xml:space="preserve">
    <value>Compiler target cannot be null.</value>
  </data>
  <data name="AstNode__GetOptimizedNode_Expression_null" xml:space="preserve">
    <value>Expression to be optimized can not be null.</value>
  </data>
  <data name="Parser__CannotUseExpressionAsAConstructor" xml:space="preserve">
    <value>Cannot use {0} like a constructor.</value>
  </data>
  <data name="AstLazyLogical__Condition_must_not_be_null" xml:space="preserve">
    <value>Condition must not be null.</value>
  </data>
  <data name="AstNode_Compiler_target_must_not_be_null" xml:space="preserve">
    <value>Compiler target must not be null.</value>
  </data>
  <data name="AstLazyLogical__targetLabel_must_neither_be_null_nor_empty" xml:space="preserve">
    <value>targetLabel must neither be null nor empty.</value>
  </data>
  <data name="AstLazyLogical_alternativeLabel_may_neither_be_null_nor_empty" xml:space="preserve">
    <value>alternativeLabel may neither be null nor empty.</value>
  </data>
  <data name="AstLazyLogical_CreatePrefixMustBeImplementedForPartialApplication" xml:space="preserve">
    <value>The lazy logical expression {0} must implement this method/property to support partial application.</value>
  </data>
  <data name="CallMacro_call_macro_must_be_supplied_a_macro_reference" xml:space="preserve">
    <value>call\macro must be supplied a macro reference.</value>
  </data>
  <data name="CallMacro_CalledFromNonMacro" xml:space="preserve">
    <value>call\macro called from {0}. call\macro can only be called from a macro context, i.e., from a macro function or an inner function of a macro.</value>
  </data>
  <data name="CallMacro_SpecifyPlaceholderIndexExplicitly" xml:space="preserve">
    <value>Due to an internal limitation, the index of a placeholder in the macro prototype's argument list inside {0} cannot be inferred. Specify the placeholders index explicitly (e.g.,  ?0, ?1, etc.).</value>
  </data>
  <data name="CallMacro_errorUsagePrototype" xml:space="preserve">
    <value>Used in this way, {0} has the form {0}([macroPrototype(...),justEffect?,call?],...).</value>
  </data>
  <data name="CallMacro_notOnPlaceholder" xml:space="preserve">
    <value>The macro prototype must be known at compile-time, it must not be a placeholder.</value>
  </data>
  <data name="CallMacro_errorUsageFullRef" xml:space="preserve">
    <value>Used in this way, {0} has the form {0}([],macroRef,[justEffect?,call?],...).</value>
  </data>
  <data name="CallStar_usage" xml:space="preserve">
    <value>{0} requires at least one argument, the call\* command/function to invoke.</value>
  </data>
  <data name="CallStar__invalid_PassThrough" xml:space="preserve">
    <value>call\star must at least pass through one argument (the call target). It has been instructed to pass through {0} arguments.</value>
  </data>
  <data name="CallSubInterpret_OneArgument" xml:space="preserve">
    <value>{0} requires one argument.</value>
  </data>
  <data name="CallSubInterpret_asExpressionInLoop" xml:space="preserve">
    <value>Due to an internal limitation, {0} and {1} cannot be used in an expression inside a loop, only as a statement.</value>
  </data>
  <data name="MacroContextExtensions_EstablishMacroContext_OutsideOfMacro" xml:space="preserve">
    <value>Cannot establish macro context outside of macro.</value>
  </data>
  <data name="Pack_Usage_obj_missing" xml:space="preserve">
    <value>Must supply an object to be transported to {0}.</value>
  </data>
  <data name="Parser_ErrorsInBuildBlock" xml:space="preserve">
    <value>Cannot execute build block. Errors detected</value>
  </data>
  <data name="Parser_exception_in_build_block" xml:space="preserve">
    <value>Exception during compilation and execution of build block.
{0}</value>
  </data>
  <data name="Parser__fallbackObjectCreation_Failed" xml:space="preserve">
    <value>Failed to transform object creation expression.</value>
  </data>
  <data name="Parser_addOpAlias_Unknown" xml:space="preserve">
    <value>Unknown operator alias in assembler code: {0}.{1}</value>
  </data>
  <data name="Reference_can_only_be_used_in_a_macro_context" xml:space="preserve">
    <value>{0} can only be used in a macro context.</value>
  </data>
  <data name="Reference_requires_at_least_one_argument" xml:space="preserve">
    <value>{0} requires at least one argument.</value>
  </data>
  <data name="Reference_requires_argument_to_be_a_prototype_of_a_macro_invocation" xml:space="preserve">
    <value>{0} requires argument to be a prototype of a macro invocation.</value>
  </data>
  <data name="CompilerTarget__CreateIncompatibleSymbolError_IncompatibleSymbol" xml:space="preserve">
    <value>Legacy part of parser cannot deal with symbol {0}. A call symbol was expected.</value>
  </data>
  <data name="AstCoalescence__reportInvalidPlaceholders" xml:space="preserve">
    <value>In partial applications of lazy coalescence expressions, only one placeholder at the end of a sequence is allowed. Consider using a lambda expression instead.</value>
  </data>
  <data name="AstNode__argumentSpliceNotSupportedInThisPosition" xml:space="preserve">
    <value>Argument splice not supported in this position.</value>
  </data>
  <data name="AstForeachLoop_DoEmitCode_ElementTooComplicated" xml:space="preserve">
    <value>Optimization of the element expression in the foreach head resulted in a non-GetSet expression. Try to use a simpler expression.</value>
  </data>
  <data name="AstLazyLogical_EmitCode_PureChainsExpected" xml:space="preserve">
    <value>Partial applications of logical statements must be either pure and-chains or pure or-chains.</value>
  </data>
  <data name="AstLazyLogical_placeholderOnlyAtTheEnd" xml:space="preserve">
    <value>In partial applications of lazy expressions, only one placeholder at the end of a sequence is allowed. Consider using a lambda expression instead.</value>
  </data>
  <data name="AstNode_NoImplementationForOperator" xml:space="preserve">
    <value>No implementation defined for operator `{0}`</value>
  </data>
  <data name="AstUnresolved_The_symbol__0__has_not_been_resolved_" xml:space="preserve">
    <value>The symbol {0} has not been resolved.</value>
  </data>
  <data name="CompilerTarget_ParameterNameReserved" xml:space="preserve">
    <value>Parameter list of function {0} contains {1} at position {2}. The name {1} is reserved for the local variable holding the argument list.</value>
  </data>
  <data name="MacroSession_NotAMacro" xml:space="preserve">
    <value>Cannot apply {0} as a macro at compile time.</value>
  </data>
  <data name="MacroSession_ExceptionDuringExpansionOfMacro" xml:space="preserve">
    <value>Exception during expansion of macro {0} in function {1}: {2}</value>
  </data>
  <data name="MacroSession_MacroCannotBeAppliedPartially" xml:space="preserve">
    <value>The macro {0} cannot be applied partially.</value>
  </data>
  <data name="MacroSession_MacroNotReentrant" xml:space="preserve">
    <value>AstMacroInvocation.EmitCode is not reentrant. The invocation node for the macro {0} has been expanded already. Use GetCopy() to operate on a copy of this macro invocation.</value>
  </data>
  <data name="MacroFunctionExpander__UsedTemporaryVariable" xml:space="preserve">
    <value>Macro {0} uses temporary variable to ensure that expression from `context.Block` is evaluated before statements from macro return value.</value>
  </data>
  <data name="MacroFunctionExpander_PartialMacroMustIndicateSuccessWithBoolean" xml:space="preserve">
    <value>Partial macro must return a boolean value, indicating whether it can handle the partial application. Assuming it cannot.</value>
  </data>
  <data name="MacroFunctionExpander_MacroFunctionNotAvailable" xml:space="preserve">
    <value>The macro function {0} was called from function {1} but is not available at compile time (from module {2}).</value>
  </data>
  <data name="MacroCommandExpander_CannotFindMacro" xml:space="preserve">
    <value>Cannot find macro command named `{0}`</value>
  </data>
  <data name="AstReturn_Warn_YieldInProtectedBlock" xml:space="preserve">
    <value>Detected possible return (yield) from within a protected block (try-catch-finally, using, foreach). This Prexonite implementation cannot guarantee that cleanup code is executed. </value>
  </data>
  <data name="AstModifyingAssignment_No_RHS" xml:space="preserve">
    <value>Invalid modifying assignment: No RHS.</value>
  </data>
  <data name="AstModifyingAssignment_AssignmentModifierNotSupported" xml:space="preserve">
    <value>The assignment modifier {0} is not supported.</value>
  </data>
  <data name="AstGetSetReference_CannotCreateReference" xml:space="preserve">
    <value>Cannot create a reference to {0} {1}.</value>
  </data>
  <data name="AstGetSetReference_ReferenceToMacroTreatedAsPartialApplication" xml:space="preserve">
    <value>Reference to macro command {0} detected. Prexonite version {1} treats this as a partial application. This behavior might change in the future. Use partial application syntax explicitly {0}(?) or use the {2} command to obtain a reference to the macro.</value>
  </data>
  <data name="AstGetSetReference_CannotAssignReference" xml:space="preserve">
    <value>Cannot assign to a reference to a {0}.</value>
  </data>
  <data name="Parser_DeclarationTypeShouldBeFollowedByColon" xml:space="preserve">
    <value>The declaration type should be followed by a colon (e.g., `declare ref var: x;`)</value>
  </data>
  <data name="AstPlaceholder_PlaceholdeIndexNegative" xml:space="preserve">
    <value>A placeholder index cannot be negtive</value>
  </data>
  <data name="SymbolBuilder_TooManyArrows" xml:space="preserve">
    <value>Cannot take a reference to a reference. Too many arrows ("-&gt;").</value>
  </data>
  <data name="SymbolHandler_CannotHandleSymbolOfType" xml:space="preserve">
    <value>The symbol handler {0} cannot handle symbols of type {1}.</value>
  </data>
  <data name="LastAccessCache_CapacityMustBePositive" xml:space="preserve">
    <value>Capacity must be strictly positive.</value>
  </data>
  <data name="AstReference_MacroCommandReferenceNotPossible" xml:space="preserve">
    <value>Cannot load a reference to a macro command. Partial application might be possible, depending on the macro command in question.</value>
  </data>
  <data name="Parser_CannotExpandAtCompileTime" xml:space="preserve">
    <value>Cannot expand {0} at compile time.</value>
  </data>
  <data name="SymbolEntryConversion_ExpansionSymbolTooComplex" xml:space="preserve">
    <value>Only expansion symbols wrapping simple references can be converted to a SymbolEntry.</value>
  </data>
  <data name="SymbolEntryConversion_BareReference" xml:space="preserve">
    <value>Cannot convert bare reference to symbol entry.</value>
  </data>
  <data name="SymbolEntryConversion_Nil" xml:space="preserve">
    <value>Cannot convert nil symbol to symbol entry.</value>
  </data>
  <data name="Parser_Could_not_find_previous_declaration" xml:space="preserve">
    <value>Could not find previous declaration for symbol {0}.</value>
  </data>
  <data name="Parser_Cannot_parse_source_position" xml:space="preserve">
    <value>Cannot parse source position from {0}.</value>
  </data>
  <data name="Parser_Cannot_parse_message_symbol" xml:space="preserve">
    <value>Cannot parse message symbol from {0}.</value>
  </data>
  <data name="Parser_Cannot_parse_symbol_from" xml:space="preserve">
    <value>Cannot parse symbol from {0}.</value>
  </data>
  <data name="ReferenceTransformer_CannotCreateReferenceToValue" xml:space="preserve">
    <value>Cannot create reference to a value (references are values too)</value>
  </data>
  <data name="Parser__assembleReference_SymbolNotDefined" xml:space="preserve">
    <value>The symbol {0} is not defined.</value>
  </data>
  <data name="Parser__assembleReference_CannotCreateReferenceToSymbol" xml:space="preserve">
    <value>Cannot create a reference to a {0}.</value>
  </data>
  <data name="ReferenceTransformer_HandleExpand_CannotCreateReferenceToDefinitionOfMacroOrPartialApplication" xml:space="preserve">
    <value>Cannot create a reference to the definition of a macro or partial application.</value>
  </data>
  <data name="Parser__assembleReference_MacroDefinitionNotLValue" xml:space="preserve">
    <value>Macro definition is not an LValue (necessary for it to be converted to a partial application)</value>
  </data>
  <data name="AstExpand_EntityMustBeMacro" xml:space="preserve">
    <value>Entity must be a macro to be expanded.</value>
  </data>
  <data name="MacroCommandExpander_MacroCommandExpected" xml:space="preserve">
    <value>MacroCommandExpander expected macro command entity. Got {0} instead.</value>
  </data>
  <data name="MacroFunctionExpander_ExpectedFunctionReference" xml:space="preserve">
    <value>MacroFunctionExpander expected reference to function, got {0} instead.</value>
  </data>
  <data name="VariableDeclaration_Variable_id_must_not_be_empty" xml:space="preserve">
    <value>Variable id must not be empty.</value>
  </data>
  <data name="UnscopedFactory_API_Misuse_symbol_resolve" xml:space="preserve">
    <value>Cannot resolve symbol in unscoped AST factory. This error message indicates a misuse of the Prexonite compile-time API.</value>
  </data>
  <data name="ParserAstFactory_RequireOuterVariable_Outside_function" xml:space="preserve">
    <value>Cannot require outer variable to be included outside of a function. This error indicates an internal compiler error.</value>
  </data>
  <data name="AstFactoryBase_UnaryOperation_Target_must_be_LValue" xml:space="preserve">
    <value>Target of an increment or decrement operations must be an LValue and a get-call.</value>
  </data>
  <data name="AstUnaryOperator__NonIncrementDecrement" xml:space="preserve">
    <value>Unary operator nodes for non-increment/decrement should not exist. This error indicates an error in the compiler.</value>
  </data>
  <data name="AstFactoryBase_UnaryOperation_NotOperatorForTypecheckRequiresLValue" xml:space="preserve">
    <value>The not operator must produce an LValue to be used in a negative typecheck.</value>
  </data>
  <data name="AstFactoryBase_ModifyingAssignment_TypeExpressionExpected" xml:space="preserve">
    <value>Right hand side of a cast operation must be a type expression.</value>
  </data>
  <data name="AstFactoryBase_BinaryOperation_TypeExprExpected" xml:space="preserve">
    <value>Type expression expected on the right-hand side of a type cast.</value>
  </data>
  <data name="AstFactoryBase__resolveImplementation_LValueExpected" xml:space="preserve">
    <value>Expected {0} to be implemented as an LValue.</value>
  </data>
  <data name="SelfAssemblingPlan_RefSpecMustHaveSource" xml:space="preserve">
    <value>The Source field of the refSpec parameter must not be null.</value>
  </data>
  <data name="SelfAssemblingPlan_RefSepcMustHaveResolvedPathForPreflightOrder" xml:space="preserve">
    <value>A preflight parse request must come with a resolved path.</value>
  </data>
  <data name="SymbolEntryConversion_Namespace" xml:space="preserve">
    <value>Cannot convert namespace to symbol entry.</value>
  </data>
  <data name="Parser_ExpectedEntityFoundNamespace" xml:space="preserve">
    <value>Found namespace, expected actual entity.</value>
  </data>
  <data name="Parser_SymbolicUsageAsLValue" xml:space="preserve">
    <value>Expected symbolic usage to be represented as an LValue.</value>
  </data>
  <data name="Parser_relativeNsId_empty" xml:space="preserve">
    <value>relativeNsId cannot be empty</value>
  </data>
  <data name="Parser_NamespaceExpected" xml:space="preserve">
    <value>Expected {0} to be a namespace. Was {1}.</value>
  </data>
  <data name="Parser_MissingMetaExprInList" xml:space="preserve">
    <value>Missing meta expression in list (two consecutive commas).</value>
  </data>
  <data name="Parser_CannotExtendMergedNamespace" xml:space="preserve">
    <value>Namespace {0} cannot be extended because it is a merged view of two originally distinct namespaces.</value>
  </data>
  <data name="SymbolMExprParser_EmptySymbolicReference" xml:space="preserve">
    <value>Symbolic reference must consist of at least one symbol name.</value>
  </data>
  <data name="Program_DebugExit" xml:space="preserve">
    <value>Exiting Prx.Main normally. Press Enter to exit.</value>
  </data>
  <data name="SelfAssemblingPlan_performCreateTargetDescription_mode" xml:space="preserve">
    <value>Must be one of RecurseIntoFileSystem or RegisterOnly.</value>
  </data>
  <data name="SelfAssemblingPlan__forbidFileRefSpec_notallowed" xml:space="preserve">
    <value>File path reference not allowed when just registering a module. Consider using ISelfAssemblingPlan.AssembleAsync instead.</value>
  </data>
  <data name="ModuleName_Module_id_cannot_be_null_or_empty_" xml:space="preserve">
    <value>Module id cannot be null or empty.</value>
  </data>
  <data name="AstIndirectCall_DoEmitPartialApplicationCode_Cannot_translate_slice" xml:space="preserve">
    <value>Cannot translate slice.</value>
  </data>
  <data name="MetaEntry_EntryTypeUnknownToString" xml:space="preserve">
    <value>MetaEntry type {0} does not have a string representation.</value>
  </data>
  <data name="Parser_DoubleColonInNamespaceName" xml:space="preserve">
    <value>Double colon (`::`) not allowed in namespace name.</value>
  </data>
  <data name="Parser_BinaryOperandMissing_Left" xml:space="preserve">
    <value>Left-hand side of {0} operation is missing.</value>
  </data>
  <data name="Parser_BinaryOperandMissing_Right" xml:space="preserve">
    <value>Right-hand side of {0} operation is missing.</value>
  </data>
</root>