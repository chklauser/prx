/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

Prexonite
=
[   InterpreterLine
]
    DeclarationLevel
    EOF
.

InterpreterLine
=
    interpreterline         (.  if(!TargetApplication.Meta.ContainsKey(Application.InterpreterLineKey)) 
                                {
                                  TargetApplication.Meta[Application.InterpreterLineKey] = t.val[2..];
                                }
                                // Don't overwrite interpreter line. Top-most wins.
                            .)
.

DeclarationLevel
                            (.  PFunction func; .)
=
{   [                       (.  if(PreflightModeEnabled)
                                {
                                    ViolentlyAbortParse();
                                    return;
                                } 
                            .)
        GlobalVariableDefinition
    |   MetaAssignment<TargetApplication>
    ]   SYNC semicolon
|                           (.  if(PreflightModeEnabled)
                                {
                                    ViolentlyAbortParse();
                                    return;
                                } 
                            .)
    (   Declaration2
    |   GlobalCode
    |   BuildBlock
    |   FunctionDefinition<out func>
    |   IF(isNamespaceImport()) NamespaceImport
    |   NamespaceDeclaration
    )
}
.

/*---- Meta information ----*/

MetaAssignment<IHasMetaTable metaTable>    (. string key = null; MetaEntry entry = null; .)
=
(   is                      (. entry = true; .)
    [not                    (. entry = false; .)
    ]
    GlobalId<out key>
|   not                     (. entry = false; .)
    GlobalId<out key>
|
    GlobalId<out key>     
    ( enabled               (. entry = true; .)
    | disabled              (. entry = false; .)
    | MetaExpr<out entry> 
    |                       (. entry = true; .)
    )                     
|   add                     (. MetaEntry subEntry; .)
    MetaExpr<out subEntry>  (. if(!subEntry.IsList) subEntry = (MetaEntry) subEntry.List; .)
    to
    GlobalId<out key>       (.  if(metaTable.Meta.ContainsKey(key))
                                {
                                    entry = metaTable.Meta[key];
                                    entry = entry.AddToList(subEntry.List);
                                }
                                else
                                {
                                   entry = subEntry;
                                }
                            .)
)                            (. if(entry == null || key == null) 
                                    SemErr("Meta assignment did not generate an entry.");
                               else 
                                    metaTable.Meta[key] = entry; 
                            .)    
.

MetaExpr<out MetaEntry entry>
              (. bool sw; int i; double r; entry = null; string str; Version v;
                 QualifiedId qualifiedId; 
              .)
=                            
  Boolean<out sw>           (. entry = sw; .)
|    Integer<out i>         (. entry = i.ToString(CultureInfo.InvariantCulture); .)
|    Real<out r>            (. entry = r.ToString(CultureInfo.InvariantCulture); .)
|   (   String<out str>     (. entry = str; .)
    |   NsQualifiedId<out qualifiedId>
                            (. entry = qualifiedId.ToString(); .)
    |   GlobalQualifiedId<out str> 
                            (. entry = str; .)
    )
    [   div
        Version<out v>      (. entry = new Prexonite.Modular.ModuleName(entry.Text,v); .)
    ]
|   lbrace                  (. List<MetaEntry> lst = new List<MetaEntry>(); 
                               MetaEntry subEntry; 
                               bool lastWasEmpty = false;
                            .)
    [   MetaExpr<out subEntry> (.  lst.Add(subEntry); .)
        {   comma           (. if(lastWasEmpty)
                                 Loader.ReportMessage(Message.Error(
                                     Resources.Parser_MissingMetaExprInList,
                                     GetPosition(), MessageClasses.DuplicateComma));
                            .)
            (   MetaExpr<out subEntry> 
                            (. lst.Add(subEntry); 
                               lastWasEmpty = false;
                            .)
            |               (. lastWasEmpty = true; .)   
            )
        }
    ]
    rbrace                  (. entry = (MetaEntry) lst.ToArray(); .)
.

/* ---- Global variable definition --- */

GlobalVariableDefinition    (.  
                                string id = null; 
                                List<string> aliases = new List<string>();
                                string primaryAlias = null;
                                VariableDeclaration vari; 
                                bool isAutodereferenced = false;
                                Symbol entry;
                            .)
=

  (   var                 
  |   ref                 (.  isAutodereferenced = true; .)
  )                       (.  var position = GetPosition(); .)
  
  (   GlobalId<out id>    (.  primaryAlias = id; .)
      [ GlobalVariableAliasList<aliases> ]
  |   GlobalVariableAliasList<aliases>
                          (.  id = null; .)
  )                       (.  id = _assignPhysicalGlobalVariableSlot(id);
                              entry = Symbol.CreateDereference(Symbol.CreateReference(
                                EntityRef.Variable.Global.Create(id, TargetModule.Name), position),position);
                              if(isAutodereferenced)
                              {
                                entry = Symbol.CreateDereference(entry, position);
                              }
                              foreach(var alias in aliases)
                                  Symbols.Declare(alias, entry);
                              DefineGlobalVariable(id,out vari);
                          .)
  [    lbrack              //Meta block for variables
    [   MetaAssignment<vari>
            {    semicolon
                [ MetaAssignment<vari> ]
        }
        ]
    rbrack
  ]                       (.  if(primaryAlias != null && !_suppressPrimarySymbol(vari))
                                    Symbols.Declare(primaryAlias, entry);
                          .)
  [                          (.  _pushLexerState(LocalState); .)
      assign              (.  _PushScope(FunctionTargets[Application.InitializationId]);
                              AstExpr expr;
                          .)
    Expr<out expr>
                          (.  _popLexerState();
                              if(errors.count == 0)
                              {
                                var complex = Create.Call(position, EntityRef.Variable.Global.Create(id,TargetModule.Name) );
                                complex.Call = PCall.Set;
                                complex.Arguments.Add(expr);
                                target.Ast.Add(complex);
                                TargetApplication._RequireInitialization();
                                Loader._EmitPartialInitializationCode();
                              }
                              _PopScope(FunctionTargets[Application.InitializationId]);
                          .)
  ]
.

GlobalVariableAliasList<. IList<string> aliases .>
                            (.  string id; .)
=
    as GlobalId<out id>     (.  aliases.Add(id); .)
    {   comma
        [ GlobalId<out id>  (.  aliases.Add(id); .) 
        ]
    }
.

/* ---- Global declaration ---- */

SymbolPrefix<SymbolBuilder symbol, out bool canBeRef> 
                            (. canBeRef = true; .) // in order to avoid further errors when this production fails
= 
  ref                       (.  symbol.Dereference(); .)
| pointer                   (.  symbol.ReferenceTo(); canBeRef = false; .)
.

EntityFactory<. bool canBeRef, out Func<string,ModuleName,EntityRef> entityFactory .> 
                            (.  entityFactory = null; bool projectNamespace = false; .)
= 
(   var                     (.  entityFactory = EntityRef.Variable.Global.Create; projectNamespace = true; .)
    | function              (.  entityFactory = EntityRef.Function.Create; projectNamespace = true; .)
    | command               (.  entityFactory = (id,_) => EntityRef.Command.Create(id); .)
    | macro             
      ( function            (.  entityFactory = EntityRef.Function.Create; projectNamespace = true; .)
      | command             (.  entityFactory = (id,_) => EntityRef.MacroCommand.Create(id); .)
      | var                 (.  entityFactory = EntityRef.Variable.Global.Create; projectNamespace = true; .)
      )
    |                       (.  if(canBeRef) 
                                {
                                  projectNamespace = true;
                                  entityFactory = EntityRef.Variable.Global.Create;
                                }
                                else
                                {
                                  // entityFactory already set to null
                                }                                
                            .)
)                           (.  // Transform physical IDs to reside in the current namespace. 
                                // That way, forward declarations end up using the same physical 
                                // name as the actual definition.
                                if(entityFactory != null && projectNamespace) {
                                    var actualFactory = entityFactory;
                                    entityFactory = (id,mn) => actualFactory(_assignPhysicalSlot(id),mn);
                                }
                            .)
.

Declaration2
                            (. ModuleName module = TargetModule.Name;
                               var builder = new SymbolBuilder();
                               Func<string,ModuleName,EntityRef> entityFactory;
                               bool canBeRef = false;
                            .)
=
SYNC
  declare
    (   { SymbolPrefix<builder, out canBeRef> }
        EntityFactory<canBeRef, out entityFactory>
                            (.  if(entityFactory == null) builder.AutoDereferenceEnabled = false; .) // For aliases, don't wrap in dereference
        [colon]
        DeclarationInstance2<entityFactory,module,builder.Clone(),preventOverride:false>
        { comma [ DeclarationInstance2<entityFactory,module,builder.Clone(),preventOverride:false> ] }
        semicolon
    |   lbrace
        [   uusing ModuleName<out module> ]
        {                   (.  var runBuilder = builder.Clone(); .)
          { SymbolPrefix<builder, out canBeRef> }
          EntityFactory<canBeRef, out entityFactory> 
                            (.  if(entityFactory == null) runBuilder.AutoDereferenceEnabled = false; .) // For aliases, don't wrap in dereference
          colon
          DeclarationInstance2<entityFactory,module,runBuilder.Clone(),preventOverride:true>
          { comma [ DeclarationInstance2<entityFactory,module,runBuilder.Clone(),preventOverride:true> ] }
        }
        rbrace
    |    lpar                (.  bool wasComma = false; .)
        [   MExprBasedDeclaration
            {   comma       (.  if(wasComma)
                                {
                                    Loader.ReportMessage(Message.Error("Double comma in declaration sequence.",GetPosition(),MessageClasses.DuplicateComma));
                                }
                                wasComma = true;
                            .)
                [   MExprBasedDeclaration
                            (.  wasComma = false; .)
                ]
            }
        ]
        rpar [ semicolon ]
    )
.

MExprBasedDeclaration       (.  string alias;
                                MExpr expr;
                            .)
=
    Id<out alias> assign MExpr<out expr>
                            (.  Symbol s = _parseSymbol(expr);
                                Symbols.Declare(alias,s);
                            .)
.

MessageDirective<.
  Func<string,ModuleName,EntityRef> entityFactory, 
  ModuleName module, 
  SymbolBuilder builder,
  [CanBeNull] out string lhsId,
  MessageSeverity severity,
  bool preventOverride = false .> 
                            (.  string message;
                                string messageClass = null;
                                ISourcePosition position = GetPosition();
                                string file;
                                int line;
                                int column;
                            .)
  =
  lpar
  (null|String<out messageClass>) 
  [ colon
    ( null
    | String<out file> colon Integer<out line> colon Integer<out column>
                            (.  position = new SourcePosition(file,line,column); .)
    )
  ]
  comma
  String<out message>
  comma                     (.  builder.AddMessage(Message.Create(severity,message,position,messageClass)); .)
  SymbolDirective<entityFactory,module,builder,out lhsId,preventOverride:preventOverride>
  rpar
.

SymbolDirective<. Func<string,ModuleName,EntityRef> entityFactory, 
  [CanBeNull] ModuleName module, 
  SymbolBuilder builder,
  [CanBeNull] out string lhsId,
  bool preventOverride = false .>
                            (.  lhsId = null;  .)
=
  null                      (.  /* don't do anything */ .)
| ( ref                     (.  builder.Dereference(); .)
  | pointer                 (.  builder.ReferenceTo(); .)
  )
  SymbolDirective<entityFactory,module,builder,out lhsId,preventOverride:preventOverride>
|    IF(isSymbolDirective("INFO"))
  id
  MessageDirective<entityFactory,module,builder, out lhsId,MessageSeverity.Info,preventOverride:preventOverride>
|    IF(isSymbolDirective("WARN"))
  id
  MessageDirective<entityFactory,module,builder, out lhsId,MessageSeverity.Warning,preventOverride:preventOverride>
|    IF(isSymbolDirective("ERROR"))
  id
  MessageDirective<entityFactory,module,builder, out lhsId,MessageSeverity.Error,preventOverride:preventOverride>
|                           (. ISourcePosition position = GetPosition(); .)
  Id<out lhsId>                
  [ div ModuleName<out module> 
                            (.  if(preventOverride) 
                                {
                                    Loader.ReportMessage(Message.Error(
                                      "Specification of module name illegal at this point.",
                                      position  ,
                                      MessageClasses.UnexpectedModuleName)); 
                                    // Let control fall through, this is not a fatal error,
                                    //  just an enforcement of a stylistic rule.
                                }
                            .)
  ]                         (.  if(entityFactory != null)
                                {
                                  builder.Entity = entityFactory(lhsId,module);
                                }
                            .)
.

DeclarationInstance2<.
  Func<string,ModuleName,EntityRef> entityFactory, 
  ModuleName module, 
  SymbolBuilder builder,
  bool preventOverride = false .>
                            (.  string lhsId;
                                string rhsId; 
                                ISourcePosition position = GetPosition(); 
                            .)
=        
  SymbolDirective<entityFactory,module,builder,out lhsId,preventOverride:preventOverride>
                            (.  rhsId = lhsId; .)
  [ as Id<out rhsId> ]
                            (.  
                                if(entityFactory == null) 
                                {
                                  // We are declaring an alias to an existing symbol
                                  Symbol existing;   
                                  if(lhsId == null)
                                  {
                                    if(rhsId == null)
                                    {
                                      Loader.ReportMessage(Message.Error(
                                        "This symbol declaration requires an alias (e.g., `as theAlias`)", 
                                        GetPosition(), 
                                        MessageClasses.SymbolAliasMissing));
                                      // Since there is no name involved, not acting on this
                                      //  statement will not cause further errors
                                    }
                                    else
                                    {
                                      Symbols.Declare(rhsId, builder.WrapSymbol(null));
                                    }
                                  }                             
                                  else if(Symbols.TryGet(lhsId,out existing)) 
                                  {
                                    // Declare $rhsId as an alias for the symbol that $lhsId points to
                                    Symbols.Declare(rhsId, builder.WrapSymbol(existing));
                                  } 
                                  else
                                  {
                                    var msg = Message.Error(string.Format(Resources.Parser_Could_not_find_previous_declaration, lhsId),
                                        position,MessageClasses.SymbolNotResolved);
                                    // We report the message AND store it as a message symbol.
                                    //  That way, the symbol is at least declared, avoiding a spurious 
                                    //  symbol not found message.
                                    Loader.ReportMessage(msg);
                                    Symbols.Declare(rhsId, Symbol.CreateMessage(msg,Symbol.CreateNil(msg.Position)));                                      
                                  }
                                }
                                else
                                {
                                  
                                  if(lhsId == null)
                                  {
                                    // For instance `declare var error(...,null)` can get us here
                                    var msg = Message.Error("Entity name missing for declaration of a fresh symbol",
                                      GetPosition(),
                                      MessageClasses.EntityNameMissing);
                                    Loader.ReportMessage(msg);
                                    // Also create an error symbol for the alias (if one was declared)
                                    if(rhsId != null)
                                      Symbols.Declare(rhsId, Symbol.CreateMessage(msg,Symbol.CreateNil(msg.Position)));
                                  }
                                  else
                                  {
                                    // Use the builder to create a new symbol.
                                    Symbols.Declare(rhsId, builder.ToSymbol());
                                  }                                  
                                }
                            .)
.

ModuleName<out ModuleName moduleName> 
                            (.  _pushLexerState(Lexer.YYINITIAL); //need global scope for Version
                                string id; 
                                Version version = null;
                            .)
=
    Id<out id>
    [   div
        Version<out version>    
    ]                       (.  _popLexerState();
                                moduleName = Loader.Cache[new ModuleName(id,version ?? new Version(0,0))];
                            .)
.

/* ---- Build Block ---- */

BuildBlock
=
  SYNC build                (.  PFunction func = TargetApplication.CreateFunction();
                                CompilerTarget buildBlockTarget = 
                                  Loader.CreateFunctionTarget(func, sourcePosition: GetPosition());
                                _PushScope(buildBlockTarget);
                                Loader.DeclareBuildBlockCommands(target);
                                _pushLexerState(LocalState);
                            .)
  
  [ does ]    
  StatementBlock<target.Ast>
  
                            (.  _popLexerState();                                    
                                  _PopScope(buildBlockTarget);
                                  _compileAndExecuteBuildBlock(buildBlockTarget);
                            .)
.

/* ---- Global Code ---- */

GlobalCode                (.  PFunction func = TargetApplication._InitializationFunction;
                      CompilerTarget ft = FunctionTargets[func];
                      ISourcePosition position;
                      if(ft == null)
                          throw new PrexoniteException("Internal compilation error: InitializeFunction got lost.");
                  .)
=
                  (.  _PushScope(ft); 
                      _pushLexerState(LocalState);
                  .)
  lbrace          (.  position = GetPosition(); .)
  { Statement<target.Ast> } 
  rbrace
                  (.
                     try {
                        if(errors.count == 0)
                        {
                          TargetApplication._RequireInitialization();
                          Loader._EmitPartialInitializationCode();
                        }
                                        } catch(Exception e) {
                                            Loader.ReportMessage(Message.Error(
                                              "Exception during compilation of initialization code.\n" + e,
                                              position,
                                              MessageClasses.ExceptionDuringCompilation));
                                        } finally {
                        //Symbols defined in this block are not available to further global code blocks
                        target.Symbols.ClearLocalDeclarations();
                        _PopScope(ft);
                        _popLexerState();
                    }
                  .)
.

/* ---- Function definition ---- */

FunctionAliasList<. IList<string> aliases .> 
                                    (.  String id; .)
=
    as Id<out id>                   (.  aliases.Add(id); .)
    {   comma 
        [   Id<out id>              (.  aliases.Add(id); .)
        ]
    }
.

FunctionDefinition<out PFunction func>
                                    (.  
                                        string primaryAlias = null;
                                        List<string> funcAliases = new List<string>();
                                        string id = null; //The logical id (given in the source code)
                                        string funcId; //The "physical" function id
                                        bool isNested = target != null; 
                                        bool isCoroutine = false;
                                        bool isMacro = false;
                                        bool isLazy = false;
                                        PFunction derBody = null; //The derived (coroutine/lazy) body function (carries a different name)
                                        PFunction derStub = null; //The derived (coroutine/lazy) stub function (carries the name(s) specified)
                                        string derId; //The name of the derived stub
                                        CompilerTarget ct = null;   //The compiler target for the function (as mentioned in the source code)
                                        CompilerTarget cst = null;  //The compiler target for a stub (coroutine/lazy)
                                        Symbol symEntry = null;
                                        ISourcePosition position;
                                        bool missingArg = false; //Allow trailing comma, but not (,,) in formal arg list
                                    .)         
=    
  (   lazy [function]             (.  isLazy = true; .)
  |   function
  |   coroutine                   (.  isCoroutine = true; .)
  |   macro [function]            (.  isMacro = true; .)
  )                               (.  position = GetPosition(); .)
  (   Id<out id>                  (.  primaryAlias = id; .)
      [ FunctionAliasList<funcAliases> ]
  |   FunctionAliasList<funcAliases>
  )                               (.  
                                      funcId = _assignPhysicalFunctionSlot(id);
                                        if(Engine.StringsAreEqual(id, @"\init")) //Treat "\init" specially (that's the initialization code)
                                        {
                                            func = TargetApplication._InitializationFunction;
                                            if(isNested)
                                                Loader.ReportMessage(Message.Error("Cannot define initialization code inside another function.",position,MessageClasses.IllegalInitializationFunction));
                                            if(isCoroutine)
                                                Loader.ReportMessage(Message.Error("Cannot define initialization code as a coroutine.",position,MessageClasses.IllegalInitializationFunction));
                                            if(isLazy)
                                                Loader.ReportMessage(Message.Error("Cannot define initialization code as a lazy function.",position,MessageClasses.IllegalInitializationFunction));
                                            if(isMacro)
                                                Loader.ReportMessage(Message.Error("Cannot define initialization code as a macro function.",position,MessageClasses.IllegalInitializationFunction));
                                        }
                                        else
                                        {
                                            var localId = id;
                                            
                                            if(isNested)
                                            {
                                                if(isMacro)
                                                    Loader.ReportMessage(Message.Error("Inner macros are illegal. Macros must be top-level.",position,MessageClasses.InnerMacrosIllegal));
                                                    
                                                funcId = generateLocalId(funcId ?? "inner");
                                                
                                                if(string.IsNullOrEmpty(localId))
                                                {
                                                    //Create shadow name
                                                    localId = generateLocalId(id ?? "inner");
                                                }
                                                var innerSym = _ensureDefinedLocal(localId, localId, true, position,true);
                                                foreach(var alias in funcAliases)
                                                    Symbols.Declare(alias, innerSym);
                                                
                                            }
                                            
                                            //Add function to application
                                            if(TargetApplication.Functions.Contains(funcId) && !TargetApplication.Meta.GetDefault(Application.AllowOverridingKey,true))
                        SemErr(t,"Application " + TargetApplication.Id + " does not allow overriding of function " + funcId + ".");
                                            TargetApplication.Functions.Remove(funcId);

                                            func = TargetApplication.CreateFunction(funcId);
                                            
                                            if(isNested)
                                            {
                                                 func.Meta[PFunction.LogicalIdKey] = localId;
                                                 if(isLazy)
                                                    mark_as_let(target.Function,localId);
                                            }
                                            
                                            Loader.CreateFunctionTarget(func, target, position);
                                        }
                                        CompilerTarget ft = FunctionTargets[func];
                                        
                                        //Generate derived stub
                                        if(isCoroutine || isLazy)
                                        {
                                            derStub = func;
                                            
                                            //Create derived body function
                                            derId = ft.GenerateLocalId();
                                            derBody = TargetApplication.CreateFunction(derId);
                                            Loader.CreateFunctionTarget(derBody, ft, position);
                                            derBody.Meta[PFunction.LogicalIdKey] = id ?? funcId;
                                            if(isCoroutine)
                                            {
                                                derBody.Meta[PFunction.VolatileKey] = true;
                                                derBody.Meta[PFunction.DeficiencyKey] = "Coroutine body can only be executed by VM anyway.";
                                                derBody.Meta[Coroutine.IsCoroutineKey] = true;
                                            }

                                            //Swap compiler target references
                                            // -> Compile source code into derived body
                                            // -> Let derived stub have the physical function id
                                            ct = FunctionTargets[derBody];
                                            cst = ft;
                                        }
                                        
                                        if(isNested) //Link to parent in case of a nested function
                                        {                                           
                                            if(isLazy)
                                                ft = ct;
                                        }                                        
                                  .)
    [   lpar
      [    FormalArg<ft> 
        {    comma               (.  if(missingArg)
                                        {
                                            SemErr("Missing formal argument (two consecutive commas).");
                                        } 
                                    .)
          (   FormalArg<ft>   (.  missingArg = false; .)
                |                   (.  missingArg = true; .)
                )
        }
      ]
      rpar
    |   FormalArg<ft>
        {   [comma]
            FormalArg<ft>
        }
  ]                                (.  if(isNested && isLazy) // keep this assignment for maintainability
                                    // ReSharper disable RedundantAssignment
                                        ft = cst;
                                    // ReSharper restore RedundantAssignment
                                      
                                      if(target == null && 
                                          (!object.ReferenceEquals(func, TargetApplication._InitializationFunction)) &&
                                          (!isNested))
                                      {
                                              //Add the name to the symbol table
                                              symEntry = Symbol.CreateReference(EntityRef.Function.Create(func.Id, TargetModule.Name),GetPosition());
                                              if(isMacro)
                                                symEntry = Symbol.CreateExpand(symEntry);
                                              else
                                                symEntry = Symbol.CreateDereference(symEntry);

                                              foreach(var alias in funcAliases)                                                    
                                                  Symbols.Declare(alias, symEntry);
                                              
                                              //Store the original (logical id, mentioned in the source code)
                                              func.Meta[PFunction.LogicalIdKey] = id ?? funcId;
                                      }
                                        else
                                        {
                                            primaryAlias = null;
                                        }
                                      
                                      //Target the derived (coroutine/lazy) body instead of the stub
                                        if(isCoroutine || isLazy)
                                            func = derBody;
                                  .)
    [                               (.  _pushLexerState(Lexer.YYINITIAL); .)
        lbrack
        [   MetaAssignment<func>
            {   semicolon
                [MetaAssignment<func>]
            }
        ]
                                    (.  _popLexerState(); .)
        rbrack
    ]
                                    (.  
                                    
                                        if(primaryAlias != null && !_suppressPrimarySymbol(func))
                                            Symbols.Declare(primaryAlias, symEntry);

                                        //Imprint certain meta keys from parent function
                                        if(isNested)
                                        {
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                        }

                                        //Copy stub parameters to body of lazy function
                                        if(isLazy && !isNested)
                                        {
                                            foreach(var kvp in cst.Symbols.LocalDeclarations)
                                            {
                                                var paramId = kvp.Key;
                                                var s = kvp.Value.ToSymbolEntry();
                                                //Lazy functions cannot have ref parameters
                                                if(s.Interpretation != SymbolInterpretations.LocalObjectVariable)
                                                    SemErr("Lazy functions can only have value parameters (ref is not allowed)");
                                                ct.Function.Parameters.Add(s.InternalId);
                                                ct.Symbols.Declare(paramId, kvp.Value);
                                            }
                                        }
                                    .)
    [                               (.  _pushLexerState(Lexer.Transfer);
                                        ISourcePosition importKeywordPosition;
                                        var importBuilder = SymbolStoreBuilder.Create();
                                    .)
        namespace
        ImportContextualKeyword<out importKeywordPosition, false>
        NsTransferSpec<importBuilder>
        {
            comma
            NsTransferSpec<importBuilder>
        }
                                    (.  {   // Copy imported symbols to import scope
                                            var it = FunctionTargets[func]; 
                                            foreach(var entry in importBuilder.ToSymbolStore())
                                                it.ImportScope.Declare(entry.Key,entry.Value);
                                        }
                                        _popLexerState(); 
                                    .)
    ]
                                    (.
                                        if(isLazy || isCoroutine)
                                        {
                                          //Push the stub, because it is the lexical parent of the body
                                          _PushScope(cst);
                                        }
                                        _PushScope(FunctionTargets[func]);
                                        Debug.Assert(target != null); // Mostly to tell ReSharper that target is not null.
                                        _pushLexerState(LocalState);
                                        if(isMacro)
                                            target.SetupAsMacro();
                                    .)
    (   does
        StatementBlock<target.Ast>
    |   lbrace {   Statement<target.Ast> }
        rbrace
    |   IF(isFollowedByStatementBlock())
        implementation
        StatementBlock<target.Ast>
    |   ( assign | implementation ) (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
        Expr<out ret.Expression>    (.  target.Ast.Add(ret); .)
        semicolon
    )                               (.  _popLexerState();
                                        _PopScope(FunctionTargets[func]);
                    if(isLazy || isCoroutine)
                    {
                      _PopScope(cst);
                    }
                                        //Compile AST
                                        if(errors.count == 0)
                                        {
                                            if(Engine.StringsAreEqual(func.Id, @"\init"))
                                            {
                                                try {
                                                TargetApplication._RequireInitialization();
                                                Loader._EmitPartialInitializationCode();
                                                //Initialize function gets finished at the end of Loader.Load
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of initialization code." + e);
                                                }
                                            }
                                            else
                                            {
                                                try {
                                                //Apply compiler hooks for all kinds of functions (lazy/coroutine/macro)
                        FunctionTargets[func].ExecuteCompilerHooks();
                        //Emit code for top-level block
                                                Ast[func].EmitCode(FunctionTargets[func], true, StackSemantics.Effect);
                                                FunctionTargets[func].FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of function body of " + id + ". " + e);
                                                }
                                            }                                       
                                            
                      if(isCoroutine)
                      {
                                                try {
                            //Stub has to be returned into the physical slot mentioned in the source code
                            func = derStub;
                            //Generate code for the stub
                            AstCreateCoroutine crcor = new AstCreateCoroutine(this);                                            
                            crcor.Expression = Create.CreateClosure(position,EntityRef.Function.Create(derBody.Id,derBody.ParentApplication.Module.Name));

                            AstReturn retst = new AstReturn(this, ReturnVariant.Exit);
                            retst.Expression = crcor;
                            cst.Ast.Add(retst);
                            //Emit code for top-level block
                            cst.Ast.EmitCode(cst,true,StackSemantics.Effect);
                            cst.FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of coroutine stub for " + id + ". " + e);
                                                }
                      }
                      else if(isLazy)
                      {
                          derStub.Meta[PFunction.LazyKey] = true;
                          derStub.Meta["strict"] = true;
                      
                          //Stub has to be returned into the physical slot mentioned in the source code
                          func = derStub;
                          
                          //Generate code for the stub
                          AstExpr retVal;                                            
                            
                            if(isNested)
                            {
                                //Nested lazy functions need a stub to capture their environment by value (handled by NestedFunction)
                                
                                //Generate stub code
                                retVal = Create.CreateClosure(position, EntityRef.Function.Create(ct.Function.Id, 
                                                ct.Function.ParentApplication.Module.Name));
                                
                                //Inject asthunk-conversion code into body
                                var inject = derStub.Parameters.Select(par => 
                                {
                                  var getParam = Create.Call(position, EntityRef.Variable.Local.Create(par));
                                  var asThunkCall = Create.Call(position, EntityRef.Variable.Command.Create(Engine.AsThunkAlias));
                                  asThunkCall.Arguments.Add(getParam);
                                  var setParam = Create.Call(position, EntityRef.Variable.Local.Create(par));
                                  setParam.Arguments.Add(asThunkCall);
                                  return (AstNode) setParam;
                                });
                                ct.Ast.InsertRange(0,inject);
                            }
                            else
                            {                                                    
                                //Global lazy functions don't technically need a stub. Might be removed later on
                                var call = Create.Call(position,EntityRef.Function.Create(ct.Function.Id, TargetModule.Name));
                                
                                //Generate code for arguments (each wrapped in a `asThunk` command call)
                              foreach(var par in derStub.Parameters)
                              {
                                  var getParam = Create.Call(position, EntityRef.Variable.Local.Create(par));
                                      
                                  var asThunkCall = Create.Call(position, EntityRef.Command.Create(Engine.AsThunkAlias));
                                      
                                  asThunkCall.Arguments.Add(getParam);
                                  call.Arguments.Add(asThunkCall);
                              }
                              
                              retVal = call;
                            }                                    
                          
                          
                          //Assemble return statement
                          var ret = new AstReturn(this, ReturnVariant.Exit);
                          ret.Expression = retVal;
                          
                          cst.Ast.Add(ret);
                          
                                                try {
                          //Emit code for stub
                          cst.Ast.EmitCode(cst,true,StackSemantics.Effect);
                          cst.FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of lazy function stub for " + id + ". " + e);
                                                }
                      }                                        
                                        }
                                    .)
.

FormalArg<CompilerTarget ft>        (.  string id; 
                                        bool isAutodereferenced = false; 
                                        ISourcePosition idPos;
                                    .)
=
  [ var | ref                       (.  isAutodereferenced = true; .)
  ]                                 (.  idPos = GetPosition(); .)
  Id<out id>                        (.  //Note: lazy functions need to copy the
                                        //  parameters of the stub to the body!
                                        ft.Function.Parameters.Add(id); 
                                        var sym = Symbol.CreateDereference(Symbol.CreateReference(
                                            EntityRef.Variable.Local.Create(id),idPos),idPos);
                                        if(isAutodereferenced)
                                            sym = Symbol.CreateDereference(sym,idPos);
                                        ft.Symbols.Declare(id, sym);
                                    .)
.

GlobalId<out string id>             (.  id = "...no freaking id..."; .)
=
    id                              (.  id = cache(t.val); .)
|   anyId  String<out id>           (.  id = cache(id); .)
.

GlobalQualifiedId<out string id>    (. id = "\\NoId\\"; .)  
=
    GlobalId<out id>
|   ns                              (.  StringBuilder buffer = new StringBuilder(t.val); buffer.Append('.'); .)
    {   ns                          (.  buffer.Append(t.val); buffer.Append('.'); .)
    }
    GlobalId<out id>                (.  buffer.Append(id); .)
                                    (.  id = cache(buffer.ToString()); .)
.

NsQualifiedId<out QualifiedId qualifiedId>
                                    (.  bool _; .)
=
NsQualifiedIdImpl<false,out qualifiedId, out _>
.

NsTransferSource<out bool hasWildcard, out QualifiedId qualifiedId>
                                    (.  hasWildcard = false; 
                                        var qualIdPos = GetPosition(); 
                                        qualifiedId = new("unknown"); 
                                    .)
=
NsQualifiedIdImpl<true, out qualifiedId, out hasWildcard>
| GlobalQualifiedId<out var gid>    (.  // This alternative covers a common but hard to spot mistake (`.` vs `::`)
                                        // It tries to recover, but it's considered a hard error.
                                        Loader.ReportMessage(Message.Error(
                                            Resources.Parser_DoubleColonInNamespaceName,
                                            qualIdPos, MessageClasses.UnexpectedDoubleColonInNamespaceName));
                                        hasWildcard = false;
                                        qualifiedId = new(gid.Split('.'));
                                    .)
.

NsQualifiedIdImpl<bool allowWildcard, out QualifiedId qualifiedId, out bool hasWildcard>
                                    (.  qualifiedId = default(QualifiedId);
                                        String part = null;
                                        var parts = new List<String>();
                                        hasWildcard = false;
                                    .)
=
GlobalId<out part>                  (.  parts.Add(part); .)
{                                   (.  if(hasWildcard)
                                        {
                                            Create.ReportMessage(Message.Error(
                                                "Unexpected qualified id parts after wildcard.",
                                                GetPosition(),
                                                MessageClasses.QualifiedIdPartsAfterWildcard
                                            ));
                                        } 
                                    .)
    dot
    (   DotId<out part>             (.  parts.Add(part); .)
    |   timessym                    (.  parts.Add(OperatorNames.Prexonite.Multiplication); .)
    |                               (.  ISourcePosition starPos = GetPosition(); .)
        times                       (.  hasWildcard = true;
                                        if(!allowWildcard)
                                        {
                                            Create.ReportMessage(Message.Error(
                                                "Unexpected wildcard in qualified namespace name.",
                                                starPos,
                                                MessageClasses.UnexpectedWildcard));
                                        }
                                    .)
    )
}                                   (.  qualifiedId = new QualifiedId(parts.ToArray()); .)
.

NsTransferDirective<.ICollection<SymbolTransferDirective> directives.>
                                    (.  string externalId;
                                        string internalId = null; .)
=                                   (.  var pos = GetPosition(); .)
(   times                           (.  directives.Add(SymbolTransferDirective.CreateWildcard(pos)); .)
|   GlobalId<out externalId>
    (   implementation GlobalId<out internalId> 
    |                               (.  internalId = externalId; .)
    )                               (.  if(internalId == null) {                
                                            // internalId is null in case of a syntax error
                                            internalId = externalId;
                                        }
                                        directives.Add(SymbolTransferDirective.CreateRename(pos, externalId, internalId));
                                    .)
|   not
    GlobalId<out externalId>        (.  directives.Add(SymbolTransferDirective.CreateDrop(pos, externalId)); .)
)
.

NsTransferDirectiveGroup<.ICollection<SymbolTransferDirective> directives.>
=
(                                   (.  _pushLexerState(Lexer.YYINITIAL); .)
    lpar
    [   NsTransferDirective<directives>
        {   comma                           
            [   NsTransferDirective<directives>
            ]
        }
    ]                               (. _popLexerState(); .)
    rpar
|                                   (.  var pos = GetPosition(); .)
    timessym                        (.  // timessym is a hack that lets `(*)`, which ordinarily appears as an identifier,
                                        // be treated as `(` `*` `)` in this special case
                                        directives.Add(SymbolTransferDirective.CreateWildcard(pos));
                                    .)
)
.

NsTransferSpec<SymbolStoreBuilder builder>
                                    (.  QualifiedId specRoot;
                                        ISourcePosition pos;
                                        ISymbolView<Symbol> sourceScope = null;
                                        var hasWildcard = false;
                                        var sourcePosition = GetNextPosition();
                                    .)
=
NsTransferSource<out hasWildcard, out specRoot>              
                                    (.  var directives = new List<SymbolTransferDirective>();
                                        pos = GetPosition();
                                    .)
(   NsTransferDirectiveGroup<directives> 
                                    (.  sourceScope = _resolveNamespace(Symbols,pos, specRoot); .)
|                                   (.  if(hasWildcard)
                                        {
                                            sourceScope = _resolveNamespace(Symbols,pos, specRoot);
                                            directives.Add(SymbolTransferDirective.CreateWildcard(pos));
                                        }
                                        else
                                        {
                                            var symId = specRoot[^1];
                                            specRoot = specRoot.WithSuffixDropped(1);
                                            if (specRoot.Count == 0)
                                            {
                                                var msg = string.Format(Resources.Parser_NsTransferSpec_Import_has_no_effect_0, symId);
                                                Loader.ReportMessage(Message.Warning(
                                                    msg,
                                                    sourcePosition,
                                                    MessageClasses.UnqualifiedImport));
                                            }
                                            sourceScope = _resolveNamespace(Symbols, pos, specRoot);
                                            directives.Add(SymbolTransferDirective.CreateRename(pos,symId,symId));
                                        }
                                    .)
)                                   (.  if(sourceScope != null)
                                            builder.Forward(
                                                new SymbolOrigin.NamespaceImport(specRoot, pos), 
                                                sourceScope, 
                                                directives); 
                                        // if the source scope is null, something has gone wrong and the error should
                                        // have already been reported
                                    .)
.

ImportContextualKeyword<out ISourcePosition importKeywordPosition, bool alternativelyExpectBrace>
                                    (.  string importKeyword; .)
=                                   (.  importKeywordPosition = GetPosition(); .)
// the `import` keyword, as a contextual keyword
GlobalId<out importKeyword>         (.  if(!Engine.StringsAreEqual(importKeyword,"import")){
                                            Loader.ReportMessage(Message.Error(
                                                System.String.Format("Expected keyword 'import'" 
                                                    + (alternativelyExpectBrace ? " or '{'" : "") 
                                                    + " instead of \"{0}\".",importKeyword),
                                                importKeywordPosition, MessageClasses.ImportExpected));
                                        } 
                                    .)
.

NamespaceImport                     (.  ISourcePosition importKeywordPosition;
                                        SymbolStoreBuilder builder = SymbolStoreBuilder.Create();
                                        // Namespace import statements are only legal on the very top level; 
                                        // In namespaces and functions, you need to use the `import` modifier of the
                                        // namespace/function declaration.
                                        // In case of a violation, we'll keep parsing to recover from the error, but we
                                        // won't make any changes to symbol tables. 
                                        bool illegal = false;
                                    .)
=
namespace                           (.  if(Loader.CurrentScope != null) {
                                          illegal = true;
                                          Loader.ReportMessage(Message.Error(
                                            "Cannot use `namespace import` inside a namespace or function. " + 
                                            "Use the `namespace|function xxx import yyy { ... }` syntax instead.", 
                                            GetPosition(),
                                            MessageClasses.NonTopLevelNamespaceImport));
                                        }
                                    .)
ImportContextualKeyword<out importKeywordPosition, false>
NsTransferSpec<builder>
{   comma
    [   NsTransferSpec<builder>
    ]
}
semicolon                           (.  if(!illegal) 
                                        {
                                            Loader.ReplaceTopLevelImports(builder);
                                        }
                                    .)
.

NamespaceDeclaration                (.  QualifiedId? fullNsId = null;
                                        DeclarationScope scope = null;
                                        ISourcePosition qualIdPos,exportPos;
                                        List<SymbolTransferDirective> directives;
                                        SymbolOrigin origin;
                                        var implicitSelfImport = true;
                                    .)
=                                   (.  .)
namespace                           (.  qualIdPos = GetPosition(); .)
(   NsQualifiedId<out var outNsId>  (.  fullNsId = outNsId; .) 
|   GlobalQualifiedId<out var qid>  (.  // This alternative captures a common and hard to spot mistake (. vs ::)
                                        // It tries to recover, but it's considered a hard error.
                                        Loader.ReportMessage(Message.Error(
                                            Resources.Parser_DoubleColonInNamespaceName,
                                            qualIdPos, MessageClasses.UnexpectedDoubleColonInNamespaceName));
                                        // Best-effort recovery based on invalid namespace name
                                        fullNsId = new QualifiedId(qid.Split('.'));
                                    .)
)                                   (.  var declBuilder = _prepareDeclScope(fullNsId ?? new QualifiedId("unknown"), qualIdPos); .)
[                                   (.  ISourcePosition importKeywordPosition;
                                        _pushLexerState(Lexer.Transfer);
                                    .)
    ImportContextualKeyword<out importKeywordPosition, false>
    // optional explicit import from current namespace exports
    (                               (.  var groupPos = GetPosition();
                                        origin = new SymbolOrigin.NamespaceImport(declBuilder.Prefix,groupPos);
                                        directives = new List<SymbolTransferDirective>();
                                    .)
        NsTransferDirectiveGroup<directives>
                                    (.  declBuilder.LocalScopeBuilder.Forward(
                                            origin, 
                                            declBuilder.Namespace, 
                                            directives); 
                                        implicitSelfImport = false;
                                    .)
    |   [   NsTransferSpec<declBuilder.LocalScopeBuilder>
        ]
    )
    // optional imports from other namespaces
    {   comma
        [   NsTransferSpec<declBuilder.LocalScopeBuilder>
        ]
    }                               (.  _popLexerState(); .)
]
/* body */                          (.  if(implicitSelfImport)
                                        {
                                            origin = new SymbolOrigin.NamespaceImport(
                                                declBuilder.Prefix,qualIdPos);
                                            declBuilder.LocalScopeBuilder.Forward(
                                                origin,
                                                declBuilder.Namespace,
                                                SymbolTransferDirective.CreateWildcard(qualIdPos).Singleton()
                                            );
                                        }
                                        Loader.PushScope(declBuilder.ToDeclarationScope()); 
                                    .)
lbrace                              
DeclarationLevel                    (.  exportPos = GetPosition(); // this position is used when there is no export-spec
                                    .)
rbrace                              (.  scope = _popDeclScope();
                                        var exportBuilder = SymbolStoreBuilder.Create(); .)
(                                   (.  _pushLexerState(Lexer.Transfer); .)
    export
    (                               (.  exportPos = GetPosition(); // this is a more accurate position
                                        origin = _privateDeclarationOrigin(exportPos,scope); 
                                        directives = new List<SymbolTransferDirective>();
                                    .)
        (   NsTransferDirectiveGroup<directives>
                                    (.  exportBuilder.Forward(origin, 
                                            _indexExportedSymbols(scope.Store), directives); .)
        |   dot times               (.  exportBuilder.Forward(origin,
                                            _indexExportedSymbols(scope.Store), 
                                            SymbolTransferDirective.CreateWildcard(exportPos).Singleton()); .)
        )
        [   {   comma
                NsTransferSpec<exportBuilder>
            }
            semicolon
        ]
    |   NsTransferSpec<exportBuilder>
        {   comma
            NsTransferSpec<exportBuilder>
        }
        semicolon
    )                               (.  _popLexerState(); .)  
|                                   (.  // In the absence of an export spec, we export
                                        // everything declared inside the namespace declaration.
                                        // This is equivalent to `export(*)`
                                        exportBuilder.Forward(
                                            _privateDeclarationOrigin(exportPos,scope), 
                                            _indexExportedSymbols(scope.Store), 
                                            SymbolTransferDirective.CreateWildcard(exportPos).Singleton()); 
                                    .)
)                                   (.  _updateNamespace(scope, exportBuilder); .)
.