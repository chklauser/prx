//-- GENERATED BY PxCoco -merge --//
//-- make sure to modify the source files instead of this one! --//

#file:C:\Users\Christian\Documents\GitHub\prx\Prexonite\Compiler\Grammar\Header.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

//A comment
using System.Collections.Generic;
using System.Linq;
using FatalError = Prexonite.Compiler.FatalCompilerException;
using StringBuilder = System.Text.StringBuilder;
using Prexonite.Compiler.Ast;
using Prexonite.Types;
using Prexonite.Modular;
using Prexonite.Compiler.Internal;
using Prexonite.Compiler.Symbolic;
using Prexonite.Compiler.Symbolic.Internal;
using Prexonite.Compiler.Symbolic.Compatibility;
using Prexonite.Properties;

COMPILER Prexonite

/*-- Global scope --*/



#file:C:\Users\Christian\Documents\GitHub\prx\Prexonite\Compiler\Grammar\Scanner.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

/*---- SCANNER ------*/

IGNORECASE
	
TOKENS
		//Basic token
		id
		anyId // $ in some situations, e.g., $"non-Prexonite id"
		lid
        ns
        version     // 1.1.1, 1.2.3.4
		
  /*--------------------------------------------------------------------------------*/
        integer
  /*--------------------------------------------------------------------------------*/
        real        // 1e, 1e5, 1.0e, 1.0e-5, 1.0e+03
        realLike    // 1.0, 2.0, 2.3 //could also be a version
  /*--------------------------------------------------------------------------------*/
        string
        
  /*--------------------------------------------------------------------------------*/
    bitAnd // &
	assign // =
	comma  // ,
	dec    // --
	div    // /
	dot    // .
	eq     // ==
	gt     // >
	ge     // >=
	inc    // ++
	lbrace // {
	lbrack // [
	lpar   // (
	lt     // <
	le     // <=
	minus  // -
	ne     // !=
	bitOr  // |
	plus   // +
	pow    // ^
	rbrace // }
    rbrack // ]
    rpar   // )
    tilde  // ~
    times  // *
    semicolon // ;
	colon  // :
	doublecolon // ::
	coalescence	//??
	question // ?
	pointer// ->
	implementation // =>
	at     // @
	appendleft // <<
	appendright // >>
	

    //Handled by the scanner:
    var
    ref
    true
	false

    //Handled by keyword check
    BEGINKEYWORDS
    mod
	is
	as
	not
	enabled
	disabled
	function
	command	
	asm	
	declare
	build
	return
	in
	to
	add
	continue
	break
	yield
	or
	and
	xor
	label
	goto
	static	
	null	
	if
	unless
	else
	new
	coroutine
	from
	do
	does
	while
	until
	for
	foreach
	try
	catch
	finally
	throw
    then
	uusing //Coco/R does not accept "using" as a token name.
	macro
	lazy
	let
	method
	this
	ENDKEYWORDS
	
    //SPECIAL
    LPopExpr //has no textual representation.

IGNORE '\r' + '\n' + '\t'

/*------------------------------*/
/*---- Parser ------------------*/
PRODUCTIONS
#file:C:\Users\Christian\Documents\GitHub\prx\Prexonite\Compiler\Grammar\Parser.Assembler.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

/* ---- Assembler Language ---- */

AsmStatementBlock<AstBlock block>
=
	lbrace
	{
	    AsmInstruction<block>        
	}
	rbrace
|   AsmInstruction<block> semicolon     
.

AsmInstruction<AstBlock block>          (.  int arguments = 0;
                                            string id;
                                            double dblArg;
                                            string insbase; string detail = null;
                                            bool bolArg;
                                            OpCode code;
                                            bool justEffect = false;
                                            int values;
                                            int rotations;
                                            int index;
                                        .)
=
    //VARIABLE DECLARATION              
                                        (. SymbolInterpretations kind = SymbolInterpretations.LocalObjectVariable; .)
    ( var | ref                         (. kind = SymbolInterpretations.LocalReferenceVariable; .)
    )
    AsmId<out id>
                                        
                                        (.  //Store variable
                                            target.Function.Variables.Add(id);
                                            SmartDeclareLocal(id, kind);
                                        .)
    {   comma
        AsmId<out id>                                        
                                        (.  //Store variable
                                            target.Function.Variables.Add(id);
                                            SmartDeclareLocal(id, kind);
                                        .)
    }
|   //OP ALIAS INSTRUCTIONS
    IF(isInOpAliasGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
                                        (.  addOpAlias(block, insbase, detail); .)
|   //NULL INSTRUCTIONS
    IF(isInNullGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code));
                                        .)
                                        
|   //LABEL
    IF( isAsmInstruction("label",null) )
    AsmId<out insbase>
    
    //Enter label
    AsmId<out id>
                                        (. addLabel(block, id); .)
|   //NOP/DATA INSTRUCTION
    IF(isAsmInstruction("nop", null))
    AsmId<out insbase>                  (.  var ins = new Instruction(OpCode.nop); .)
    [  plus AsmId<out id>               (.  ins = ins.With(id: id); .)
    ]
                                        (.  addInstruction(block, ins); .)
    
|   //ROTATE INSTRUCTION
    IF(isAsmInstruction("rot", null))
    AsmId<out insbase>
    dot Integer<out rotations>
    comma Integer<out values>    
                                        //Create rot instruction
                                        (.  addInstruction(block, Instruction.CreateRotate(rotations, values)); .)
   
|	//INDIRECT LOCAL CALL BY INDEX
	IF(isAsmInstruction("indloci", null))
	[ at                                (.  justEffect = true; .)
	]
	AsmId<out insbase>
	dot Integer<out arguments>
	Integer<out index>
										//Create indloci instruction
										(.	addInstruction(block, Instruction.CreateIndLocI(index, arguments, justEffect)); .)    
|   //EXCHANGE INSTRUCTION
    IF(isAsmInstruction("swap", null))
    AsmId<out insbase>
                                        (.  addInstruction(block, Instruction.CreateExchange()); .)
   
    
|   //LOAD CONSTANT . REAL
    IF(isAsmInstruction("ldc", "real"))
    AsmId<out insbase>
    dot
    AsmId<out detail>    
    SignedReal<out dblArg>                    
                                        (.  addInstruction(block, Instruction.CreateConstant(dblArg)); .)
    

|   //LOAD CONSTANT . BOOL    
    IF(isAsmInstruction("ldc", "bool"))
    AsmId<out insbase>
    dot
    AsmId<out detail>
    Boolean<out bolArg>     
                                        (.  addInstruction(block, Instruction.CreateConstant(bolArg)); .)
    
    
|   //INTEGER INSTRUCTIONS
    IF(isInIntegerGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
    SignedInteger<out arguments>
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code, arguments));
                                        .)
                                        
|   //JUMP INSTRUCTIONS
    IF(isInJumpGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
                                        (.  Instruction ins = null;
                                            code = getOpCode(insbase, detail);
                                        .)
    //Symbolic:
    (   AsmId<out id>
                                        (.  
                                            ins = new Instruction(code, -1, id);
                                        .)
    |   Integer<out arguments>          (.  ins = new Instruction(code, arguments); .)
    )                                   (.  addInstruction(block, ins); .)
    

|   //ID INSTRUCTIONS
    IF(isInIdGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
    AsmId<out id>
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code, id));
                                        .)
    

|   //ID+ARG INSTRUCTIONS
    IF(isInIdArgGroup())
    [ at                                (.  justEffect = true; .)
    ]
    AsmId<out insbase>
    (   dot Integer<out arguments>
    |                                   (.  arguments = 0; .)
    )
    AsmId<out id>
                                        (.  code = getOpCode(insbase, null);
                                            addInstruction(block, new Instruction(code, arguments, id, justEffect));
                                        .)
 
 |   //ARG INSTRUCTIONS
    IF(isInArgGroup())
    [ at                                (.  justEffect = true; .)
    ]
    AsmId<out insbase>
    (   dot Integer<out arguments>
    |                                   (.  arguments = 0; .)
    )
                                        (.  code = getOpCode(insbase, null);
                                            addInstruction(block, new Instruction(code, arguments, null, justEffect));
                                        .)   

|   //QUALID+ARG INSTRUCTIONS
    IF(isInQualidArgGroup())
    [ at                                (.  justEffect = true; .)
    ]
    AsmId<out insbase>
    (   dot Integer<out arguments>
    |                                   (.  arguments = 0; .)
    )
    AsmQualid<out id>
                                        (.  code = getOpCode(insbase, null);
                                            addInstruction(block, new Instruction(code, arguments, id, justEffect));
                                        .)

|   //ERROR PRODUCTION: INVALID INSTRUCTION
    AsmId<out insbase>                  (.  SemErr("Invalid assembler instruction \"" + insbase + "\" (" + t + ")."); .)
        
.

AsmId<out string id>        (.  id = "\\NoId\\"; .)
=
    String<out id>
|   Id<out id>
|   (   mod
    |   is
    |   not
    //  enabled
    //  disabled
    //  build
    |   return
    |   in
    |   to
    //  add
    |   continue
    |   break
    |   or
    |   and
    |   xor
    |   goto
    |   null
    |   else
    |   if
    |   unless
    |   new
    |   while
    |   until
    |   for
    |   foreach
    |   command
    |   as
    |	try
    |	throw
    )                       (.  id = cache(t.val); .)
.

AsmQualid<out string qualid>
                            (.   .)
=
    AsmId<out qualid>
.
#file:C:\Users\Christian\Documents\GitHub\prx\Prexonite\Compiler\Grammar\Parser.Expression.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */


Expr<out AstExpr expr>		    (.	AstConditionalExpression cexpr; expr = null; .)
=	
	AtomicExpr<out expr>   
|										(.	bool isNegated = false; .)
	(	if
	|	unless							(.	isNegated = true; .)
	)
	lpar Expr<out expr> rpar			(.	cexpr = new AstConditionalExpression(this, expr, isNegated); .)
	Expr<out cexpr.IfExpression>
    else
    Expr<out cexpr.ElseExpression>      (.  expr = cexpr; .)
.


AtomicExpr<out AstExpr expr>
                                        (.  AstExpr outerExpr; .)
=
    AppendRightExpr<out expr>
    {
        then
        AppendRightExpr<out outerExpr>  (.  var thenExpr = Create.Call(GetPosition(), EntityRef.Command.Create(Engine.ThenAlias));
                                            thenExpr.Arguments.Add(expr);
                                            thenExpr.Arguments.Add(outerExpr);
                                            expr = thenExpr;
                                        .)
    }
.


AppendRightExpr<out AstExpr expr>
										(.	AstGetSet complex; .)
=
	KeyValuePairExpr<out expr>
	{	
		appendright
		GetCall<out complex>		    (.	_appendRight(expr,complex);
										    expr = complex;										    
									    .)
	}
.

KeyValuePairExpr<out AstExpr expr>
=
	OrExpr<out expr>
	[	colon							(.	AstExpr value; .)
		KeyValuePairExpr<out value>		(.	expr = new AstKeyValuePair(this, expr, value); .)
	]
.

OrExpr<out AstExpr expr>
										(. AstExpr lhs, rhs; .)
=
	AndExpr<out lhs>                    (.  expr = lhs; .)
    [   or OrExpr<out rhs>              (.  expr = new AstLogicalOr(this, lhs, rhs); .)
    ]

.

AndExpr<out AstExpr expr>
                                        (. AstExpr lhs, rhs; .)
=
    BitOrExpr<out lhs>                  (.  expr = lhs; .)
    [   and AndExpr<out rhs>            (.  expr = new AstLogicalAnd(this, lhs, rhs); .)
    ]
.

BitOrExpr<out AstExpr expr>
                                        (. AstExpr lhs, rhs; .)
=
    BitXorExpr<out lhs>                 (. expr = lhs; .)
    { bitOr BitXorExpr<out rhs>         (. expr =Create.BinaryOperation(GetPosition(), expr, BinaryOperator.BitwiseOr, rhs); .)
    }
.

BitXorExpr<out AstExpr expr>
                                        (.  AstExpr lhs, rhs; .)
=
    BitAndExpr<out lhs>                 (.  expr = lhs; .)
    {   xor BitAndExpr<out rhs>
                                        (.  expr = Create.BinaryOperation(GetPosition(), expr, BinaryOperator.ExclusiveOr, rhs); .)
    }
.

BitAndExpr<out AstExpr expr>
                                        (.  AstExpr lhs, rhs; .)
=
    NotExpr<out lhs>                    (.  expr = lhs; .)
    {   bitAnd NotExpr<out rhs>
                                        (.  expr = Create.BinaryOperation(GetPosition(), expr, BinaryOperator.BitwiseAnd, rhs); .)
    }
.

NotExpr<out AstExpr expr>
                                        (. AstExpr lhs; bool isNot = false; .)
=
    [   not                             (.  isNot = true; .)
    ]
    EqlExpr<out lhs>                    (.  expr = isNot ? Create.UnaryOperation(GetPosition(), UnaryOperator.LogicalNot, lhs) : lhs; .)
.

EqlExpr<out AstExpr expr>
                                        (. AstExpr lhs, rhs; BinaryOperator op; .)
=
    RelExpr<out lhs>                    (. expr = lhs; .)
    {   (   eq                          (.  op = BinaryOperator.Equality; .)
        |   ne                          (.  op = BinaryOperator.Inequality; .)    
        ) RelExpr<out rhs>              (.  expr = Create.BinaryOperation(GetPosition(), expr, op, rhs); .)
    }
.

RelExpr<out AstExpr expr>
                                        (.  AstExpr lhs, rhs; BinaryOperator op;  .)
=
    CoalExpr<out lhs>                   (.  expr = lhs; .)
    {   (   lt                          (.  op = BinaryOperator.LessThan;              .)
        |   le                          (.  op = BinaryOperator.LessThanOrEqual;       .)
        |   gt                          (.  op = BinaryOperator.GreaterThan;           .)
        |   ge                          (.  op = BinaryOperator.GreaterThanOrEqual;    .)
        ) CoalExpr<out rhs>             (.  expr = Create.BinaryOperation(GetPosition(), expr, op, rhs); .)
    }
.

CoalExpr<out AstExpr expr>
										(.	AstExpr lhs, rhs; AstCoalescence coal = new AstCoalescence(this); .)
=
	AddExpr<out lhs>					(.	expr = lhs; coal.Expressions.Add(lhs); .)
	{
		coalescence
		AddExpr<out rhs>				(.	expr = coal; coal.Expressions.Add(rhs); .)
	}
.										

AddExpr<out AstExpr expr>
                                        (.  AstExpr lhs,rhs; BinaryOperator op; .)
=
    MulExpr<out lhs>                    (.  expr = lhs; .)
    {   (   plus                        (.  op = BinaryOperator.Addition;      .)
        |   minus                       (.  op = BinaryOperator.Subtraction;   .) 
        ) MulExpr<out rhs>              (.  expr = Create.BinaryOperation(GetPosition(), expr, op, rhs); .)
    }
.

MulExpr<out AstExpr expr>
                                        (.  AstExpr lhs, rhs; BinaryOperator op; .)
=
    PowExpr<out lhs>                    (.  expr = lhs; .)
    {   (   times                       (.  op = BinaryOperator.Multiply;      .)
        |   div                         (.  op = BinaryOperator.Division;        .)
        |   mod                         (.  op = BinaryOperator.Modulus;       .)
        ) PowExpr<out rhs>              (.  expr = Create.BinaryOperation(GetPosition(), expr, op, rhs); .)
    }
.

PowExpr<out AstExpr expr>
                                        (.  AstExpr lhs, rhs; .)
=
    AssignExpr<out lhs>                  (.  expr = lhs; .)
    {   pow AssignExpr<out rhs>          (.  expr = Create.BinaryOperation(GetPosition(), expr, BinaryOperator.Power, rhs); .)
    }
.

AssignExpr<out AstExpr expr>     (.  AstGetSet assignment; BinaryOperator setModifier = BinaryOperator.None;
                                            AstTypeExpr typeExpr;
                                            ISourcePosition position;
                                        .)
=                                       (.  position = GetPosition(); .)
    PostfixUnaryExpr<out expr>
    (IF(isAssignmentOperator())
                                       (.  assignment = expr as AstGetSet;
                                            if(assignment == null) 
                                            {
                                                SemErr(string.Format("Cannot assign to a {0}",
                                                    expr.GetType().Name));
                                                assignment = _NullNode(GetPosition()); //to prevent null references
                                            }
                                            assignment.Call = PCall.Set;
                                        .)
        (                               
            (   assign                  (.  setModifier = BinaryOperator.None; .)
	        |   plus assign             (.  setModifier = BinaryOperator.Addition; .)
	        |   minus assign            (.  setModifier = BinaryOperator.Subtraction; .)
	        |   times assign            (.  setModifier = BinaryOperator.Multiply; .)
	        |   div assign              (.  setModifier = BinaryOperator.Division; .)
	        |   bitAnd assign           (.  setModifier = BinaryOperator.BitwiseAnd; .)
	        |   bitOr assign            (.  setModifier = BinaryOperator.BitwiseOr; .)
	        |	coalescence assign		    (.	setModifier = BinaryOperator.Coalescence; .)
	        )   Expr<out expr>        //(.  expr = expr; .)
	        
	    |   (   tilde  assign           (.  setModifier = BinaryOperator.Cast; .)
	        )TypeExpr<out typeExpr>     (.  expr = typeExpr; .)
	    )                               
	                                    (.  assignment.Arguments.Add(expr); 
	                                        if(setModifier == BinaryOperator.None)
	                                            expr = assignment;
	                                        else
	                                            expr = Create.ModifyingAssignment(position,assignment,setModifier);
                                        .)        
    |)
.

PostfixUnaryExpr<out AstExpr expr>
                                        (.  AstTypeExpr type; AstGetSet extension; bool isInverted = false; .)
=
    PrefixUnaryExpr<out expr>           (.  var position = GetPosition(); .)
    {   tilde TypeExpr<out type>        (.  expr = new AstTypecast(this, expr, type); .)
    |   is	                            
        [ not						    (.	isInverted = true; .) 
        ]
    		 TypeExpr<out type>         (.  expr = new AstTypecheck(this, expr, type);
    										if(isInverted)
                                            {
                                                ((AstTypecheck)expr).IsInverted = true;
    											expr = Create.UnaryOperation(position, UnaryOperator.LogicalNot, expr);
                                            }
    									.)
    |   inc                             (.  expr = Create.UnaryOperation(position, UnaryOperator.PostIncrement, expr); .)
    |   dec                             (.  expr = Create.UnaryOperation(position, UnaryOperator.PostDecrement, expr); .)
    |   GetSetExtension<expr, out extension>
                                        (.  expr = extension; .)
    }
.

PrefixUnaryExpr<out AstExpr expr>
                                        (.  var prefixes = new Stack<UnaryOperator>(); .)
=                                       (.  var position = GetPosition(); .)
    {   plus
    |   minus                           (.  prefixes.Push(UnaryOperator.UnaryNegation); .)
    |   inc                             (.  prefixes.Push(UnaryOperator.PreIncrement); .)
    |   dec                             (.  prefixes.Push(UnaryOperator.PreDecrement); .)
    }    
    Primary<out expr>                   
                                        (.  while(prefixes.Count > 0)
                                                expr = Create.UnaryOperation(position, prefixes.Pop(), expr);
                                        .)
.

Primary<out AstExpr expr>
                                        (.  expr = null;
                                        .)
=
	(.  _pushLexerState(Lexer.Asm); .)	  (.  var blockExpr = Create.Block(GetPosition());
											                      _PushScope(blockExpr);
										                    .)
    asm lpar { AsmInstruction<blockExpr> } rpar
    (.  _popLexerState(); .)			      (.	expr = blockExpr; 
											                      _PopScope(blockExpr);
										                    .)
|   Constant<out expr>
|   ThisExpression<out expr>
|   CoroutineCreation<out expr>
|   ListLiteral<out expr>
|	HashLiteral<out expr>
|	LoopExpr<out expr>
|	(. AstThrow th; .)
	ThrowExpression<out th>				(. expr = th; .)
|   IF(isLambdaExpression())
    LambdaExpression<out expr>
|   LazyExpression<out expr>
|   lpar Expr<out expr> rpar
|   IF(_isNotNewDecl()) ObjectCreation<out expr>
|   GetInitiator<out expr>
|   LPopExpr lpar Expr<out expr>        (.  //This is a hack that makes string interpolation with expressions possible
                                            //The non-verbal token "LPopExpr" (has no character representation) is 
                                            //returned by the lexer if the parser has to treat an expression in a special
                                            //way. This includes notifying the lexer when the expression has been parsed, as
                                            //well as injecting the necessary plus operator.
                                            _popLexerState(); _inject(_plus); .)
    rpar
.

Constant<out AstExpr expr>
                                        (.  expr = null; int vi; double vr; bool vb; string vs; .)
=
        Integer<out vi>                 (.  expr = new AstConstant(this, vi); .)
    |   Real<out vr>                    (.  expr = new AstConstant(this, vr); .)
    |   Boolean<out vb>                 (.  expr = new AstConstant(this, vb); .)
    |   String<out vs>                  (.  expr = new AstConstant(this, vs); .)
    |   Null							(.  expr = new AstConstant(this, null); .)
.

ListLiteral<out AstExpr expr>
                                        (.  AstExpr iexpr; 
                                            AstListLiteral lst = new AstListLiteral(this);
                                            expr = lst;
                                            bool missingExpr = false;
                                        .)
=
    lbrack
    [   Expr<out iexpr>                 (.  lst.Elements.Add(iexpr); .)
        {   comma                       (.  if(missingExpr)
                                                SemErr("Missing expression in list literal (two consecutive commas).");
                                        .)
            (   Expr<out iexpr>         (.  lst.Elements.Add(iexpr); 
                                            missingExpr = false; 
                                        .)
            |                           (.  missingExpr = true; .)
            )
        }
    ]
    rbrack
.

HashLiteral<out AstExpr expr>
										(.	AstExpr iexpr; 
											AstHashLiteral hash = new AstHashLiteral(this);
											expr = hash;
                                            bool missingExpr = false;
										.)
=
	lbrace
	[	Expr<out iexpr>					(.	hash.Elements.Add(iexpr); .)
		{	comma                       (.  if(missingExpr)
                                                SemErr("Missing expression in list literal (two consecutive commas).");
                                        .)
            (   Expr<out iexpr>			(.	hash.Elements.Add(iexpr); 
                                            missingExpr = false;
                                        .)
            |                           (.  missingExpr = true; .)
            )
		}
	]
	rbrace
.

LoopExpr<out AstExpr expr>
										(.	var dummyBlock = Create.Block(GetPosition());
											_PushScope(dummyBlock);
											expr = _NullNode(GetPosition());
										.)
=
	(	WhileLoop<dummyBlock>
	|	ForLoop<dummyBlock>
	|	ForeachLoop<dummyBlock>
	)									(.	_PopScope(dummyBlock);
											SemErr("Loop expressions are no longer supported.");
										.)
.										
											

ObjectCreation<out AstExpr expr>
                                        (.  AstTypeExpr type; 
                                            ArgumentsProxy args; 
                                        .)
=
    new TypeExpr<out type>              (.  _fallbackObjectCreation(type, out expr, out args); .)
    Arguments<args>
.

CoroutineCreation<out AstExpr expr>
                                        (.  
                                            AstCreateCoroutine cor = new AstCreateCoroutine(this); 
                                            AstExpr iexpr;
                                            expr = cor;
                                        .)
=
    coroutine Expr<out iexpr>           (.  cor.Expression = iexpr; .)
    [ for Arguments<cor.Arguments> ]
.

LambdaExpression<out AstExpr expr>
                                        (.  PFunction func = TargetApplication.CreateFunction(generateLocalId());                                             
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                            func.Meta[PFunction.ParentFunctionKey] = target.Function.Id;
                                            Loader.CreateFunctionTarget(func, target, GetPosition());
                                            CompilerTarget ft = FunctionTargets[func];
                                            ISourcePosition position;
                                        .)
=
                                        (.  position = GetPosition(); .)
(   FormalArg<ft>
|   lpar
    [	FormalArg<ft> 
	    {	comma
		    FormalArg<ft>
	    }
    ]
    rpar
)
                                        (.  _PushScope(ft); .)
implementation                                        
(   lbrace
    { Statement<ft.Ast> }
    rbrace
|                                       (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
    Expr<out ret.Expression>            (.  ft.Ast.Add(ret); .)
)
                                        (.
                                            _PopScope(ft);
                                            if(errors.count == 0)
                                            {
                                                try {
                                                    //Emit code for top-level block
                                                    Ast[func].EmitCode(FunctionTargets[func],true,StackSemantics.Effect);
                                                    FunctionTargets[func].FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of lambda expression.\n" + e);
                                                }
                                            }
                                            
                                            expr = Create.CreateClosure(position,EntityRef.Function.Create(func.Id,func.ParentApplication.Module.Name));
                                        .)
.

LazyExpression<out AstExpr expr>
                                        (.  PFunction func = TargetApplication.CreateFunction(generateLocalId());
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                            func.Meta[PFunction.ParentFunctionKey] = target.Function.Id;
                                            Loader.CreateFunctionTarget(func, target, GetPosition());
                                            CompilerTarget ft = FunctionTargets[func];
                                            ISourcePosition position;
                                            
                                            //Switch to nested target
                                            _PushScope(ft);
                                        .)
=                                       
lazy                                    (.  position = GetPosition(); .)
(   lbrace
    { Statement<ft.Ast> }
    rbrace
|                                       (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
    Expr<out ret.Expression>            (.  ft.Ast.Add(ret); .)
)                                       
                                        (.
                                            //Turn into capture by value
                                            var cap = ft._ToCaptureByValue(let_bindings(ft));
                                            
                                            //Restore parent target
                                            _PopScope(ft);
                                            
                                            //Finish nested function
                                            if(errors.count == 0)
                                            {
                                                try {
													Ast[func].EmitCode(FunctionTargets[func],true,StackSemantics.Effect);
													FunctionTargets[func].FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of lazy expression.\n" + e);
                                                }
                                            }
                                            
                                            //Construct expr (appears in the place of lazy expression)
                                            var clo = Create.CreateClosure(position,EntityRef.Function.Create(func.Id,func.ParentApplication.Module.Name));
                                            var thunk = Create.IndirectCall(position,Create.Reference(position,EntityRef.Command.Create(Engine.ThunkAlias)));
                                            thunk.Arguments.Add(clo);
                                            thunk.Arguments.AddRange(cap(this)); //Add captured values
                                            expr = thunk;
                                        .)
.

ThrowExpression<out AstThrow th>		(.  th = new AstThrow(this); .)
=
    throw
    Expr<out th.Expression>
.

ThisExpression<out AstExpr expr>        (.  var position = GetPosition();
                                            expr = Create.IndirectCall(position,Create.Null(position));
                                        .)
=
    this                                (.  Loader.ReportMessage(Message.Error("Illegal use of reserved keyword `this`.",position,MessageClasses.ThisReserved)); .)
.

ExplicitTypeExpr<out AstTypeExpr type>     (.  type = null; .)
=
    tilde PrexoniteTypeExpr<out type>
|   ClrTypeExpr<out type>
.

TypeExpr<out AstTypeExpr type>             (.  type = null; .)
=
    PrexoniteTypeExpr<out type>
|   ClrTypeExpr<out type>
.

ClrTypeExpr<out AstTypeExpr type>          
                                        (.  string id; .)
=
                                        (.  StringBuilder typeId = new StringBuilder(); .)
    (   doublecolon
    |   ns                              (.  typeId.Append(t.val); typeId.Append('.'); .)
    )
    {   ns                              (.  typeId.Append(t.val); typeId.Append('.'); .)
    }
    Id<out id>                          (.  typeId.Append(id);
                                            type = new AstConstantTypeExpression(this, 
                                                "Object(\"" + StringPType.Escape(typeId.ToString()) + "\")");
                                        .)
.

PrexoniteTypeExpr<out AstTypeExpr type>
                                        (.  string id = null; .)
=
    ( Id<out id> | null                 (.  id = NullPType.Literal; .)                          
    )
                                        (.  AstDynamicTypeExpression dType = new AstDynamicTypeExpression(this, id); .)
    [   lt
        [   TypeExprElement<dType.Arguments>   
            { comma TypeExprElement<dType.Arguments> }
        ]
        gt
    ]
                                        (.  type = dType; .)
.

TypeExprElement<. List<AstExpr> args .>
                                        (.  AstExpr expr; AstTypeExpr type; .)
=
    Constant<out expr>                  (.  args.Add(expr); .)
|   ExplicitTypeExpr<out type>          (.  args.Add(type); .)
|   lpar Expr<out expr> rpar            (.  args.Add(expr); .)
.
#file:C:\Users\Christian\Documents\GitHub\prx\Prexonite\Compiler\Grammar\Parser.GlobalScope.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

Prexonite	
                            (.  PFunction func; .)				
=
    {   [   GlobalVariableDefinition
        |   MetaAssignment<TargetApplication>
        ]   SYNC semicolon
    |   Declaration2
    |   GlobalCode
    |   BuildBlock
    |   FunctionDefinition<out func>
    }
    EOF
.

/*---- Meta information ----*/

MetaAssignment<IHasMetaTable metaTable>	(. string key = null; MetaEntry entry = null; .)
=
(	is  					(. entry = true; .)
  [not					(. entry = false; .)
  ]
  GlobalId<out key>
|   not                     (. entry = false; .)
    GlobalId<out key>
|
  GlobalId<out key>
  ( enabled				(. entry = true; .)
  | disabled  			(. entry = false; .)
  | MetaExpr<out entry>
    |                       (. entry = true; .)
  )
|   add                     (. MetaEntry subEntry; .)
    MetaExpr<out subEntry>  (. if(!subEntry.IsList) subEntry = (MetaEntry) subEntry.List; .)
    to
    GlobalId<out key>       (.  if(metaTable.Meta.ContainsKey(key))
                                {
                                    entry = metaTable.Meta[key];
                                    entry = entry.AddToList(subEntry.List);
                                }
                                else
                                {
                                   entry = subEntry;
                                }
                            .)
)							(. if(entry == null || key == null) 
                                    SemErr("Meta assignment did not generate an entry.");
                               else 
                                    metaTable.Meta[key] = entry; 
                            .)	
.

MetaExpr<out MetaEntry entry>
              (. bool sw; int i; double r; entry = null; string str; .)
=							
  Boolean<out sw>			(. entry = sw; .)
|	Integer<out i>			(. entry = i.ToString(CultureInfo.InvariantCulture); .)
|	Real<out r>				(. entry = r.ToString(CultureInfo.InvariantCulture); .)
|   String<out str>         (. entry = str; .)
|   GlobalQualifiedId<out str>       (. entry = str; .)
|   lbrace                  (. List<MetaEntry> lst = new List<MetaEntry>(); 
                               MetaEntry subEntry; 
                               bool lastWasEmpty = false;
                            .)
    [   MetaExpr<out subEntry> (.  lst.Add(subEntry); .)
        {   comma           (. if(lastWasEmpty)
                                    SemErr("Missing meta expression in list (two consecutive commas).");
                            .)
            (   MetaExpr<out subEntry> 
                            (. lst.Add(subEntry); 
                               lastWasEmpty = false;
                            .)
            |               (. lastWasEmpty = true; .)   
            )
        }
    ]
    rbrace                  (. entry = (MetaEntry) lst.ToArray(); .)
.

/* ---- Global variable definition --- */

GlobalVariableDefinition	(.  
                                string id = null; 
                                List<string> aliases = new List<string>();
                                string primaryAlias = null;
                                VariableDeclaration vari; 
                                SymbolInterpretations type = SymbolInterpretations.GlobalObjectVariable; 
                                SymbolEntry entry;
                            .)
=

  (   var                 
  |   ref                 (.  type = SymbolInterpretations.GlobalReferenceVariable; .)
  )                       (.  var position = GetPosition(); .)
  
  (   GlobalId<out id>    (.  primaryAlias = id; .)
      [ GlobalVariableAliasList<aliases> ]
  |   GlobalVariableAliasList<aliases>
                          (.  id = Engine.GenerateName("v"); .)
  )
                          (.
                                entry = new SymbolEntry(type,id, TargetModule.Name);
                              foreach(var alias in aliases)
                                  Symbols.Declare(alias, entry.ToSymbol());
                                DefineGlobalVariable(id,out vari);
                          .)
  [	lbrack  		    //Meta block for variables
    [   MetaAssignment<vari>
            {	semicolon
                [ MetaAssignment<vari> ]
        }
        ]
    rbrack
  ]                       (.  if(primaryAlias != null && !_suppressPrimarySymbol(vari))
                                    Symbols.Declare(primaryAlias, entry.ToSymbol());
                          .)
  [	                      (.  _pushLexerState(Lexer.Local); .)
      assign              (.  _PushScope(FunctionTargets[Application.InitializationId]);
                              AstExpr expr;
                          .)
    Expr<out expr>
                          (.  _popLexerState();
                              if(errors.count == 0)
                              {
                                var complex = Create.Call(position, EntityRef.Variable.Global.Create(id,TargetModule.Name) );
                                complex.Call = PCall.Set;
                                complex.Arguments.Add(expr);
                                target.Ast.Add(complex);
                                TargetApplication._RequireInitialization();
                                Loader._EmitPartialInitializationCode();
                              }
                              _PopScope(FunctionTargets[Application.InitializationId]);
                          .)
  ]
.

GlobalVariableAliasList<. IList<string> aliases .>
                            (.  string id; .)
=
    as GlobalId<out id>     (.  aliases.Add(id); .)
    {   comma
        [ GlobalId<out id>  (.  aliases.Add(id); .) 
        ]
    }
.

/* ---- Global declaration ---- */

SymbolPrefix<SymbolBuilder symbol, out bool canBeRef> 
                            (. canBeRef = true; .) // in order to avoid further errors when this production fails
= 
  ref                       (.  symbol.Dereference(); .)
| pointer                   (.  symbol.ReferenceTo(); canBeRef = false; .)
.

EntityFactory<. bool canBeRef, out Func<string,ModuleName,EntityRef> entityFactory .> 
                            (.  entityFactory = null; .)
= var                       (.  entityFactory = EntityRef.Variable.Global.Create; .)
| function                  (.  entityFactory = EntityRef.Function.Create; .)
| command                   (.  entityFactory = (id,_) => EntityRef.Command.Create(id); .)
| macro             
  ( function                (.  entityFactory = EntityRef.Function.Create; .)
  | command                 (.  entityFactory = (id,_) => EntityRef.MacroCommand.Create(id); .)
  | var                     (.  entityFactory = EntityRef.Variable.Global.Create; .)
  )
|                           (.  if(canBeRef) 
                                {
                                  entityFactory = EntityRef.Variable.Global.Create;
                                }
                                else
                                {
                                  // entityFactory already set to null
                                }                                
                            .)
.

Declaration2
                            (. ModuleName module = TargetModule.Name;
                               SymbolBuilder builder = new SymbolBuilder();
                               Func<string,ModuleName,EntityRef> entityFactory;
                               bool canBeRef = false;
                            .)
=
SYNC
  declare
    (   { SymbolPrefix<builder, out canBeRef> }
        EntityFactory<canBeRef, out entityFactory>
                            (.  if(entityFactory == null) builder.AutoDereferenceEnabled = false; .) // For aliases, don't wrap in dereference
        ( colon
        |                   (.  Loader.ReportMessage(Message.Warning(
                                  Resources.Parser_DeclarationTypeShouldBeFollowedByColon,
                                  GetPosition(),
                                  MessageClasses.MissingColonInDeclaration));
                            .)
        )
        DeclarationInstance2<entityFactory,module,builder.Clone(),preventOverride:false>
        { comma [ DeclarationInstance2<entityFactory,module,builder.Clone(),preventOverride:false> ] }
        semicolon
    |   lbrace
        [   uusing ModuleName<out module> ]
        {                   (.  SymbolBuilder runBuilder = builder.Clone(); .)
          { SymbolPrefix<builder, out canBeRef> }
          EntityFactory<canBeRef, out entityFactory> 
                            (.  if(entityFactory == null) runBuilder.AutoDereferenceEnabled = false; .) // For aliases, don't wrap in dereference
          colon
          DeclarationInstance2<entityFactory,module,runBuilder.Clone(),preventOverride:true>
          { comma [ DeclarationInstance2<entityFactory,module,runBuilder.Clone(),preventOverride:true> ] }
        }
        rbrace
	|	lpar                (.  bool wasComma = false; .)
        [   MExprBasedDeclaration
            {   comma       (.  if(wasComma)
                                {
                                    Loader.ReportMessage(Message.Error("Double comma in declaration sequence.",GetPosition(),MessageClasses.DuplicateComma));
                                }
                                wasComma = true;
                            .)
                [   MExprBasedDeclaration
                            (.  wasComma = false; .)
                ]
            }
        ]
        rpar [ semicolon ]
    )
.

MExprBasedDeclaration       (.  string alias;
                                MExpr expr;
                            .)
=
    Id<out alias> assign MExpr<out expr>
                            (.  Symbol s = _parseSymbol(expr);
                                Symbols.Declare(alias,s);
                            .)
.

MessageDirective<.
  Func<string,ModuleName,EntityRef> entityFactory, 
  ModuleName module, 
  SymbolBuilder builder,
  [CanBeNull] out string lhsId,
  MessageSeverity severity,
  bool preventOverride = false .> 
                            (.  string message;
                                string messageClass = null;
                                ISourcePosition position = GetPosition();
                                string file;
                                int line;
                                int column;
                            .)
  =
  lpar
  (null|String<out messageClass>) 
  [ colon
    ( null
    | String<out file> colon Integer<out line> colon Integer<out column>
                            (.  position = new SourcePosition(file,line,column); .)
    )
  ]
  comma
  String<out message>
  comma                     (.  builder.AddMessage(Message.Create(severity,message,position,messageClass)); .)
  SymbolDirective<entityFactory,module,builder,out lhsId,preventOverride:preventOverride>
  rpar
.

SymbolDirective<. Func<string,ModuleName,EntityRef> entityFactory, 
  [CanBeNull] ModuleName module, 
  SymbolBuilder builder,
  [CanBeNull] out string lhsId,
  bool preventOverride = false .>
                            (.  lhsId = null;  .)
=
  null                      (.  /* don't do anything */ .)
| ( ref                     (.  builder.Dereference(); .)
  | pointer                 (.  builder.ReferenceTo(); .)
  )
  SymbolDirective<entityFactory,module,builder,out lhsId,preventOverride:preventOverride>
|	IF(isSymbolDirective("INFO"))
  id
  MessageDirective<entityFactory,module,builder, out lhsId,MessageSeverity.Info,preventOverride:preventOverride>
|	IF(isSymbolDirective("WARN"))
  id
  MessageDirective<entityFactory,module,builder, out lhsId,MessageSeverity.Warning,preventOverride:preventOverride>
|	IF(isSymbolDirective("ERROR"))
  id
  MessageDirective<entityFactory,module,builder, out lhsId,MessageSeverity.Error,preventOverride:preventOverride>
|                           (. ISourcePosition position = GetPosition(); .)
  Id<out lhsId>                
  [ div ModuleName<out module> 
                            (.  if(preventOverride) 
                                {
                                    Loader.ReportMessage(Message.Error(
                                      "Specification of module name illegal at this point.",
                                      position  ,
                                      MessageClasses.UnexpectedModuleName)); 
                                    // Let control fall through, this is not a fatal error,
                                    //  just an enforcement of a stylistic rule.
                                }
                            .)
  ]                         (.  if(entityFactory != null)
                                {
                                  builder.Entity = entityFactory(lhsId,module);
                                }
                            .)
.

DeclarationInstance2<.
  Func<string,ModuleName,EntityRef> entityFactory, 
  ModuleName module, 
  SymbolBuilder builder,
  bool preventOverride = false .>
                            (.  string lhsId;
                                string rhsId; 
                                ISourcePosition position = GetPosition(); 
                            .)
=		
  SymbolDirective<entityFactory,module,builder,out lhsId,preventOverride:preventOverride>
                            (.  rhsId = lhsId; .)
  [ as Id<out rhsId> ]
                            (.  
                                if(entityFactory == null) 
                                {
                                  // We are declaring an alias to an existing symbol
                                  Symbol existing;   
                                  if(lhsId == null)
                                  {
                                    if(rhsId == null)
                                    {
                                      Loader.ReportMessage(Message.Error(
                                        "This symbol declaration requires an alias (e.g., `as theAlias`)", 
                                        GetPosition(), 
                                        MessageClasses.SymbolAliasMissing));
                                      // Since there is no name involved, not acting on this
                                      //  statement will not cause further errors
                                    }
                                    else
                                    {
                                      Symbols.Declare(rhsId, builder.WrapSymbol(null));
                                    }
                                  }                             
                                  else if(Symbols.TryGet(lhsId,out existing)) 
                                  {
                                    // Declare $rhsId as an alias for the symbol that $lhsId points to
                                    Symbols.Declare(rhsId, builder.WrapSymbol(existing));
                                  } 
                                  else
                                  {
                                    var msg = Message.Error(string.Format(Resources.Parser_Could_not_find_previous_declaration, lhsId),
		                                position,MessageClasses.SymbolNotResolved);
                                    // We report the message AND store it as a message symbol.
                                    //  That way, the symbol is at least declared, avoiding a spurious 
                                    //  symbol not found message.
                                    Loader.ReportMessage(msg);
                                    Symbols.Declare(rhsId, Symbol.CreateMessage(msg,Symbol.CreateNil(msg.Position)));                                      
                                  }
                                }
                                else
                                {
                                  
                                  if(lhsId == null)
                                  {
                                    // For instance `declare var error(...,null)` can get us here
                                    var msg = Message.Error("Entity name missing for declaration of a fresh symbol",
                                      GetPosition(),
                                      MessageClasses.EntityNameMissing);
                                    Loader.ReportMessage(msg);
                                    // Also create an error symbol for the alias (if one was declared)
                                    if(rhsId != null)
                                      Symbols.Declare(rhsId, Symbol.CreateMessage(msg,Symbol.CreateNil(msg.Position)));
                                  }
                                  else
                                  {
                                    // Use the builder to create a new symbol.
                                    Symbols.Declare(rhsId, builder.ToSymbol());
                                  }                                  
                                }
                            .)
.

ModuleName<out ModuleName moduleName> 
                            (.  _pushLexerState(Lexer.YYINITIAL); //need global scope for Version
                                string id; 
                                Version version = null;
                            .)
=
    Id<out id>
    [   div
        Version<out version>    
    ]                       (.  _popLexerState();
                                moduleName = Loader.Cache[new ModuleName(id,version ?? new Version(0,0))];
                            .)
.

/* ---- Build Block ---- */

BuildBlock
=
  SYNC build                (.  PFunction func = TargetApplication.CreateFunction();
                                CompilerTarget buildBlockTarget = 
                                  Loader.CreateFunctionTarget(func, sourcePosition: GetPosition());
                                _PushScope(buildBlockTarget);
                                Loader.DeclareBuildBlockCommands(target);
                                _pushLexerState(Lexer.Local);                                
                            .)
  
  [ does ]	
  StatementBlock<target.Ast>
  
                            (.  _popLexerState();                                    
                                  _PopScope(buildBlockTarget);
                                  _compileAndExecuteBuildBlock(buildBlockTarget);
                            .)
.

/* ---- Global Code ---- */

GlobalCode				(.  PFunction func = TargetApplication._InitializationFunction;
                      CompilerTarget ft = FunctionTargets[func];
                      ISourcePosition position;
                      if(ft == null)
                          throw new PrexoniteException("Internal compilation error: InitializeFunction got lost.");
                  .)
=
                  (.	_PushScope(ft); 
                      _pushLexerState(Lexer.Local);
                  .)
  lbrace          (.  position = GetPosition(); .)
  { Statement<target.Ast> } 
  rbrace
                  (.
                     try {
                        if(errors.count == 0)
                        {
                          TargetApplication._RequireInitialization();
                          Loader._EmitPartialInitializationCode();
                        }
                                        } catch(Exception e) {
                                            Loader.ReportMessage(Message.Error(
                                              "Exception during compilation of initialization code.\n" + e,
                                              position,
                                              MessageClasses.ExceptionDuringCompilation));
                                        } finally {
                        //Symbols defined in this block are not available to further global code blocks
                        target.Symbols.ClearLocalDeclarations();
                        _PopScope(ft);
                        _popLexerState();
                    }
                  .)
.

/* ---- Function definition ---- */

FunctionAliasList<. IList<string> aliases .> 
                                    (.  String id; .)
=
    as Id<out id>                   (.  aliases.Add(id); .)
    {   comma 
        [   Id<out id>              (.  aliases.Add(id); .)
        ]
    }
.

FunctionDefinition<out PFunction func>
                                    (.  
                                        string primaryAlias = null;
                                        List<string> funcAliases = new List<string>();
                                        string id = null; //The logical id (given in the source code)
                                        string funcId; //The "physical" function id
                                        bool isNested = target != null; 
                                        bool isCoroutine = false;
                                        bool isMacro = false;
                                        bool isLazy = false;
                                        PFunction derBody = null; //The derived (coroutine/lazy) body function (carries a different name)
                                        PFunction derStub = null; //The derived (coroutine/lazy) stub function (carries the name(s) specified)
                                        string derId; //The name of the derived stub
                                        CompilerTarget ct = null;   //The compiler target for the function (as mentioned in the source code)
                                        CompilerTarget cst = null;  //The compiler target for a stub (coroutine/lazy)
                                        Symbol symEntry = null;
                                        ISourcePosition position;
                                        bool missingArg = false; //Allow trailing comma, but not (,,) in formal arg list
                                    .)         
=	
  (   lazy [function]             (.  isLazy = true; .)
  |   function
  |   coroutine                   (.  isCoroutine = true; .)
  |   macro [function]            (.  isMacro = true; .)
  )                               (.  position = GetPosition(); .)
  (   Id<out id>                  (.  primaryAlias = id; .)
      [ FunctionAliasList<funcAliases> ]
  |   FunctionAliasList<funcAliases>
  )                               (.  
                                      funcId = id ?? Engine.GenerateName("f");
                                        if(Engine.StringsAreEqual(id, @"\init")) //Treat "\init" specially (that's the initialization code)
                                        {
                                            func = TargetApplication._InitializationFunction;
                                            if(isNested)
                                                Loader.ReportMessage(Message.Error("Cannot define initialization code inside another function.",GetPosition(),MessageClasses.IllegalInitializationFunction));
                                            if(isCoroutine)
                                                Loader.ReportMessage(Message.Error("Cannot define initialization code as a coroutine.",GetPosition(),MessageClasses.IllegalInitializationFunction));
                                            if(isLazy)
                                                Loader.ReportMessage(Message.Error("Cannot define initialization code as a lazy function.",GetPosition(),MessageClasses.IllegalInitializationFunction));
                                            if(isMacro)
                                                Loader.ReportMessage(Message.Error("Cannot define initialization code as a macro function.",GetPosition(),MessageClasses.IllegalInitializationFunction));
                                        }
                                        else
                                        {
                                            var localId = id;
                                            
                                            if(isNested)
                                            {
                                                if(isMacro)
                                                    Loader.ReportMessage(Message.Error("Inner macros are illegal. Macros must be top-level.",GetPosition(),MessageClasses.InnerMacrosIllegal));
                                                    
                                                funcId = generateLocalId(id ?? "inner");
                                                
                                                if(string.IsNullOrEmpty(localId))
                                                {
                                                    //Create shadow name
                                                    localId = generateLocalId(id ?? "inner");
                                                }
                                                SmartDeclareLocal(localId, SymbolInterpretations.LocalReferenceVariable);
                                                foreach(var alias in funcAliases)
                                                        SmartDeclareLocal(alias, localId, SymbolInterpretations.LocalReferenceVariable, false);
                                                
                                            }
                                            
                                            //Add function to application
                                            if(TargetApplication.Functions.Contains(funcId) && !TargetApplication.Meta.GetDefault(Application.AllowOverridingKey,true))
                        SemErr(t,"Application " + TargetApplication.Id + " does not allow overriding of function " + funcId + ".");
                                            TargetApplication.Functions.Remove(funcId);

                                            func = TargetApplication.CreateFunction(funcId);
                                            
                                            if(isNested)
                                            {
                                                 func.Meta[PFunction.LogicalIdKey] = localId;
                                                 if(isLazy)
                                                    mark_as_let(target.Function,localId);
                                            }
                                            
                                            Loader.CreateFunctionTarget(func, target, GetPosition());
                                        }
                                        CompilerTarget ft = FunctionTargets[func];
                                        
                                        //Generate derived stub
                                        if(isCoroutine || isLazy)
                                        {
                                            derStub = func;
                                            
                                            //Create derived body function
                                            derId = ft.GenerateLocalId();
                                            derBody = TargetApplication.CreateFunction(derId);
                                            Loader.CreateFunctionTarget(derBody, ft, GetPosition());
                                            derBody.Meta[PFunction.LogicalIdKey] = id ?? funcId;
                                            if(isCoroutine)
                                            {
                                                derBody.Meta[PFunction.VolatileKey] = true;
                                                derBody.Meta[PFunction.DeficiencyKey] = "Coroutine body can only be executed by VM anyway.";
                                                derBody.Meta[Coroutine.IsCoroutineKey] = true;
                                            }

                                            //Swap compiler target references
                                            // -> Compile source code into derived body
                                            // -> Let derived stub have the physical function id
                                            ct = FunctionTargets[derBody];
                                            cst = ft;
                                        }
                                        
                                        if(isNested) //Link to parent in case of a nested function
                                        {                                           
                                            if(isLazy)
                                                ft = ct;
                                        }	                                    
                                  .)
    [   lpar
      [	FormalArg<ft> 
        {	comma               (.  if(missingArg)
                                        {
                                            SemErr("Missing formal argument (two consecutive commas).");
                                        } 
                                    .)
          (   FormalArg<ft>   (.  missingArg = false; .)
                |                   (.  missingArg = true; .)
                )
        }
      ]
      rpar
    |   FormalArg<ft>
        {   [comma]
            FormalArg<ft>
        }
  ]	                            (.  if(isNested && isLazy) // keep this assignment for maintainability
                                    // ReSharper disable RedundantAssignment
                                        ft = cst;
                                    // ReSharper restore RedundantAssignment
                                      
                                      if(target == null && 
                                          (!object.ReferenceEquals(func, TargetApplication._InitializationFunction)) &&
                                          (!isNested))
                                      {
                                              //Add the name to the symbol table
                                              symEntry = Symbol.CreateReference(EntityRef.Function.Create(func.Id, TargetModule.Name),GetPosition());
                                              if(isMacro)
                                                symEntry = Symbol.CreateExpand(symEntry);
                                              else
                                                symEntry = Symbol.CreateDereference(symEntry);

                                              foreach(var alias in funcAliases)	                                                
                                                  Symbols.Declare(alias, symEntry);
                                              
                                              //Store the original (logical id, mentioned in the source code)
                                              func.Meta[PFunction.LogicalIdKey] = id ?? funcId;
                                      }
                                        else
                                        {
                                            primaryAlias = null;
                                        }
                                      
                                      //Target the derived (coroutine/lazy) body instead of the stub
                                        if(isCoroutine || isLazy)
                                            func = derBody;
                                  .)
    [                               (.  _pushLexerState(Lexer.YYINITIAL); .)
        lbrack
        [   MetaAssignment<func>
            {   semicolon
                [MetaAssignment<func>]
            }
        ]
                                    (.  _popLexerState(); .)
        rbrack
    ]
                                    (.  
                                    
                                        if(primaryAlias != null && !_suppressPrimarySymbol(func))
                                            Symbols.Declare(primaryAlias, symEntry);

                                        //Imprint certain meta keys from parent function
                                        if(isNested)
                                        {
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                        }

                                        //Copy stub parameters to body of lazy function
                                        if(isLazy && !isNested)
                                      {
                                          foreach(var kvp in cst.Symbols.LocalDeclarations)
                                          {
                                              var paramId = kvp.Key;
                                              var s = kvp.Value.ToSymbolEntry();
                                              //Lazy functions cannot have ref parameters
                                              if(s.Interpretation != SymbolInterpretations.LocalObjectVariable)
                                                  SemErr("Lazy functions can only have value parameters (ref is not allowed)");
                                              ct.Function.Parameters.Add(s.InternalId);
                                              ct.Symbols.Declare(paramId, kvp.Value);
                                          }
                                      }
                                    
                    if(isLazy || isCoroutine)
                    {
                      //Push the stub, because it is the lexical parent of the body
                      _PushScope(cst);
                    }
                                        _PushScope(FunctionTargets[func]);
                                        Debug.Assert(target != null); // Mostly to tell ReSharper that target is not null.
                                        _pushLexerState(Lexer.Local);
                                        if(isMacro)
                                            target.SetupAsMacro();
                                    .)
    (   [ does ]
        StatementBlock<target.Ast>
    |   IF(isFollowedByStatementBlock())
        implementation
        StatementBlock<target.Ast>
    |   ( assign | implementation ) (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
        Expr<out ret.Expression>    (.  target.Ast.Add(ret); .)
        semicolon
    )                               (.  _popLexerState();
                                        _PopScope(FunctionTargets[func]);
                    if(isLazy || isCoroutine)
                    {
                      _PopScope(cst);
                    }
                                        //Compile AST
                                        if(errors.count == 0)
                                        {
                                            if(Engine.StringsAreEqual(func.Id, @"\init"))
                                            {
                                                try {
                                                TargetApplication._RequireInitialization();
                                                Loader._EmitPartialInitializationCode();
                                                //Initialize function gets finished at the end of Loader.Load
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of initialization code." + e);
                                                }
                                            }
                                            else
                                            {
                                                try {
                                                //Apply compiler hooks for all kinds of functions (lazy/coroutine/macro)
                        FunctionTargets[func].ExecuteCompilerHooks();
                        //Emit code for top-level block
                                                Ast[func].EmitCode(FunctionTargets[func], true, StackSemantics.Effect);
                                                FunctionTargets[func].FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of function body of " + id + ". " + e);
                                                }
                                            }                                       
                                            
                      if(isCoroutine)
                      {
                                                try {
                            //Stub has to be returned into the physical slot mentioned in the source code
                            func = derStub;
                            //Generate code for the stub
                            AstCreateCoroutine crcor = new AstCreateCoroutine(this);                                            
                            crcor.Expression = Create.CreateClosure(GetPosition(),EntityRef.Function.Create(derBody.Id,derBody.ParentApplication.Module.Name));

                            AstReturn retst = new AstReturn(this, ReturnVariant.Exit);
                            retst.Expression = crcor;
                            cst.Ast.Add(retst);
                            //Emit code for top-level block
                            cst.Ast.EmitCode(cst,true,StackSemantics.Effect);
                            cst.FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of coroutine stub for " + id + ". " + e);
                                                }
                      }
                      else if(isLazy)
                      {
                          derStub.Meta[PFunction.LazyKey] = true;
                          derStub.Meta["strict"] = true;
                      
                          //Stub has to be returned into the physical slot mentioned in the source code
                          func = derStub;
                          
                          //Generate code for the stub
                          AstExpr retVal;										    
                            
                            if(isNested)
                            {
                                //Nested lazy functions need a stub to capture their environment by value (handled by NestedFunction)
                                
                                //Generate stub code
                                retVal = Create.CreateClosure(GetPosition(), EntityRef.Function.Create(ct.Function.Id, 
                                                ct.Function.ParentApplication.Module.Name));
                                
                                //Inject asthunk-conversion code into body
                                var inject = derStub.Parameters.Select(par => 
                                {
                                  var getParam = Create.Call(position, EntityRef.Variable.Local.Create(par));
                                  var asThunkCall = Create.Call(position, EntityRef.Variable.Command.Create(Engine.AsThunkAlias));
                                  asThunkCall.Arguments.Add(getParam);
                                  var setParam = Create.Call(position, EntityRef.Variable.Local.Create(par));
                                  setParam.Arguments.Add(asThunkCall);
                                  return (AstNode) setParam;
                                });
                                ct.Ast.InsertRange(0,inject);
                            }
                            else
                            {										            
                                //Global lazy functions don't technically need a stub. Might be removed later on
                                var call = Create.Call(position,EntityRef.Function.Create(ct.Function.Id, TargetModule.Name));
                                
                                //Generate code for arguments (each wrapped in a `asThunk` command call)
                              foreach(var par in derStub.Parameters)
                              {
                                  var getParam = Create.Call(position, EntityRef.Variable.Local.Create(par));
                                      
                                  var asThunkCall = Create.Call(position, EntityRef.Command.Create(Engine.AsThunkAlias));
                                      
                                  asThunkCall.Arguments.Add(getParam);
                                  call.Arguments.Add(asThunkCall);
                              }
                              
                              retVal = call;
                            }								    
                          
                          
                          //Assemble return statement
                          var ret = new AstReturn(this, ReturnVariant.Exit);
                          ret.Expression = retVal;
                          
                          cst.Ast.Add(ret);
                          
                                                try {
                          //Emit code for stub
                          cst.Ast.EmitCode(cst,true,StackSemantics.Effect);
                          cst.FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of lazy function stub for " + id + ". " + e);
                                                }
                      }                                        
                                        }
                                    .)
.

FormalArg<CompilerTarget ft>        (.  string id; SymbolInterpretations kind = SymbolInterpretations.LocalObjectVariable; .)
=
  [ var | ref                     (.  kind = SymbolInterpretations.LocalReferenceVariable; .)
  ]
  Id<out id>                      (.  
                                      //Note: lazy functions need to copy the
                                      //  parameters of the stub to the body!
                                      ft.Function.Parameters.Add(id); 
                                      ft.Symbols.Declare(id, new SymbolEntry(kind, id, null).ToSymbol());
                                  .)
.

GlobalId<out string id>             (.  id = "...no freaking id..."; .)
=
    id                              (.  id = cache(t.val); .)
|   anyId  String<out id>           (.  id = cache(id); .)
.

GlobalQualifiedId<out string id>    (. id = "\\NoId\\"; .)  
=
    GlobalId<out id>
|   ns                              (.  StringBuilder buffer = new StringBuilder(t.val); buffer.Append('.'); .)
    {   ns                          (.  buffer.Append(t.val); buffer.Append('.'); .)
    }
    GlobalId<out id>                (.  buffer.Append(id); .)
                                    (.  id = cache(buffer.ToString()); .)
.
#file:C:\Users\Christian\Documents\GitHub\prx\Prexonite\Compiler\Grammar\Parser.Helper.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

Id<out string id>               (.  id = "\\NoId\\"; .) //<-- should never surface. this is for debugging purposes
=
    GlobalId<out id>
|   (   enabled
    |   disabled
    |   build
    |   add
    )                           (.  id = cache(t.val); .)
.

Boolean<out bool value>         (.  value = true; .)
=                   
	true          
|	false                       (.  value = false; .)
.

Integer<out int value>
=
	integer                     (.  if(!TryParseInteger(t.val, out value))
	                                    SemErr(t, "Cannot recognize integer " + t.val);
	                            .)
.

SignedInteger<out int value>    (. int modifier = 1; .)
=
    [   plus
    |   minus                   (. modifier = -1; .)
    ]   Integer<out value>      (. value = modifier * value; .)
.

Real<out double value>  
=
	(real | realLike)           (.  string real = t.val;
	                                if(!TryParseReal(real, out value))
	                                    SemErr(t, "Cannot recognize real " + real);
	                            .)
.

Version<out Version version>    // Cannot distinguish between Real and Version  must not appear in the same context.
=
    (realLike | version)        (.  var raw = t.val;
                                    if(!TryParseVersion(raw, out version))
									{
                                        SemErr(t,"Cannot recognize \"" + raw + "\" as a version literal.");
										version = new Version(0,0);
									}
                                .)
.

SignedReal<out double value>    (. value = 0.0; double modifier = 1.0; int ival; .)
=
    [   plus
    |   minus                   (. modifier = -1.0; .)
    ]   ( Real<out value> 
        | Integer<out ival>     (. value = ival; .)
        )
                                (. value = modifier * value; .)
.

String<out string value>
=
    string                      (. value = cache(t.val); .)
.

Null = null .

MId<out String id>	            (.  id = "an\\invalid\\MId"; .)			
=
(	var
|   ref
|   true
|	false
|   mod
|	is
|	as
|	not
|	function
|	command	
|	asm	
|	declare
|	build
|	return
|	in
|	to
|	continue
|	break
|	yield
|	or
|	and
|	xor
|	label
|	goto
|	static	// null is not a valid MExpr id. It is used to represent an MAtom with a null value
|	if
|	unless
|	else
|	new
|	coroutine
|	from
|	do
|	does
|	while
|	until
|	for
|	foreach
|	try
|	catch
|	finally
|	throw
|	then
|	uusing //Coco/R does not accept "using" as a token name.
|	macro
|	lazy
|	let
|	method
|	this
|	bitAnd
|	pow
|	times
|	tilde
|	question
|	pointer
|	at
|	colon
|	implementation
)								(.	id = cache(t.val); .)
|	Id<out id>
.

MExpr<out MExpr expr>			(.  expr = new MExpr.MAtom(NoSourcePosition.Instance,null);
                                    bool lastWasComma = false;
                                .)
=								(.	String id; 
									var args = new List<MExpr>();
									MExpr arg;
								.)
	MId<out id>
	(	lpar					
		[	MExpr<out arg>		(.	args.Add(arg); .)
			{	comma           (.  if(lastWasComma)
                                    {
                                        Loader.ReportMessage(Message.Error("Double comma in MExpr list.",GetPosition(),MessageClasses.DuplicateComma));
                                    }
                                    lastWasComma = true; 
                                .)
				[   MExpr<out arg>	
                                (.	args.Add(arg); 
                                    lastWasComma = false;
                                .)
                ]
			}
		]
		rpar
	|	MExpr<out arg>			(.	args.Add(arg); .)
	|							(.	/* no M-Expr args */ .)
	)							(.	expr = new MExpr.MList(GetPosition(), id,args); .)
|								(.  String value; .)
	String<out value>			(.	expr = new MExpr.MAtom(GetPosition(), value); .)
|								(.	int intval; .)
	SignedInteger<out intval>	(.	expr = new MExpr.MAtom(GetPosition(), intval); .)
|								(.	bool boolval; .)
	Boolean<out boolval>		(.	expr = new MExpr.MAtom(GetPosition(), boolval); .)
|                               (.  Version v; .)
    Version<out v>              (.  expr = new MExpr.MAtom(GetPosition(), v); .)
|	
    Null                        (.  expr = new MExpr.MAtom(GetPosition(), null); .)
.
#file:C:\Users\Christian\Documents\GitHub\prx\Prexonite\Compiler\Grammar\Parser.Statement.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

StatementBlock<AstBlock block>
=
	Statement<block>
.

Statement<AstBlock block>
=
(
		IF( isLabel() )
			ExplicitLabel<block>  
	|   [ SimpleStatement<block> ] semicolon
	|   StructureStatement<block>
)
{	and Statement<block> 
}
.

SimpleStatement<AstBlock block>
=
	ExplicitGoTo<block>
|   GetSetComplex<block>
|   Return<block>
|   Throw<block>
|   LetBindingStmt<block>
.

StructureStatement<AstBlock block>
=
    (.  _pushLexerState(Lexer.Asm); .)
    asm AsmStatementBlock<block>
    (.  _popLexerState(); .)
|   Condition<block>
|   Declaration2
|   WhileLoop<block>
|   ForLoop<block>
|   ForeachLoop<block>
|   NestedFunction<block>
|   TryCatchFinally<block>
|   Using<block>
|	lbrace
	{
		Statement<block>
	}
	rbrace
.

GetSetComplex<AstBlock block>
                                        (.  AstGetSet complex; 
                                            AstExpr expr;
                                            AstNode node;
                                        .)
=
//GetSet Initiator
GetInitiator<out expr>                  (.  complex = expr as AstGetSet; .)

//GetSet Extensions
{   GetSetExtension<expr, out complex>  (.  expr = complex; .)
}
//GetSet Terminator
(                                       (.  if(expr != null) // Happens in case of an error
                                                block.Add(expr); 
                                        .)
|                                       (.  var pos = GetPosition(); 
                                            if(complex == null)
                                            {                                                
                                                Loader.ReportMessage(Message.Error("Expected an LValue (Get/Set-Complex) for ++,-- or assignment statement.",pos,MessageClasses.LValueExpected));
                                                complex = Create.IndirectCall(pos,Create.Null(pos));
                                            }                                            
                                        .)
    (   inc                             (.  block.Add(Create.UnaryOperation(pos, UnaryOperator.PostIncrement, complex)); .)
    |   dec                             (.  block.Add(Create.UnaryOperation(pos, UnaryOperator.PostDecrement, complex)); .)
    |   Assignment<complex, out node>   (.  if(complex == null && node == null)
                                            {
                                                // An error ocurred during parsing prior to this point.
                                                // Don't add the null node to the block to avoid a ArgumentNullException
                                            }
                                            else if(node == null)
                                            {
                                                Loader.ReportMessage(Message.Error("Internal error during translation of assignment. This is likely caused by an error reported previously.",GetPosition(),MessageClasses.ParserInternal));
                                            }
                                            else
                                            {
                                                block.Add(node);
                                            }
                                        .)
    |	AppendRightTermination<ref complex>
	    {	AppendRightTermination<ref complex>
	    }
										(.	block.Add(complex);  .)  
    )
)
.

AppendRightTermination<ref AstGetSet complex>
		                                (.	AstGetSet rhs; .)
=
	appendright
	GetCall<out rhs>                    (.	_appendRight(complex,rhs);
										    complex = rhs;
										.)
.

GetSetExtension<AstExpr subject, out AstGetSet extension>
                                        (.  extension = null; string id;
											if(subject == null)
											{
												SemErr("Member access not preceded by a proper expression.");
												subject = new AstConstant(this,null);
											}
                                        .)
                                        
=
    IF( isIndirectCall() )
    dot                                 (.  extension = new AstIndirectCall(this, PCall.Get, subject); .)
    Arguments<extension.Arguments>
|   dot
    Id<out id>                          (.  extension = new AstGetSetMemberAccess(this, PCall.Get, subject, id); .)
    Arguments<extension.Arguments> 
|                                       (.  
                                            AstExpr expr; 
                                            extension = new AstGetSetMemberAccess(this, PCall.Get, subject, ""); 
                                        .)
    lbrack [
            Expr<out expr>              (.  extension.Arguments.Add(expr); .)  
            { WEAK comma Expr<out expr>   (.  extension.Arguments.Add(expr); .)
            }
        ]                                             
    rbrack                                                                      
.

GetInitiator<out AstExpr complex>
                                        (.  complex = null; 
                                            AstGetSet actualComplex = null;
                                            AstGetSetStatic staticCall = null;
                                            AstGetSet member = null;
                                            AstExpr expr;
                                            List<AstExpr> args = new List<AstExpr>();
                                            string id;
                                            int placeholderIndex = -1;
											                      ISourcePosition position;
                                        .)
=
    //Actual value
    (   SymbolicUsage<out actualComplex>
                                        (.  complex = actualComplex; .)
    |   VariableDeclaration<out actualComplex>
                                        (.  complex = actualComplex; .)
    |   StaticCall<out staticCall>
    |	lpar Expr<out expr>				(.	args.Add(expr); .)
		{	comma Expr<out expr>		(.	args.Add(expr); .) //multiple expressions can only be used as arguments
		}
		rpar
		(	GetSetExtension<expr, out member>
										(.	if(args.Count > 1)
												SemErr("A member access cannot have multiple subjects. (Did you mean '>>'?)");
										.)
		|	appendright
			GetCall<out actualComplex>  (.  _appendRight(args,actualComplex);
                                            complex = actualComplex;
										.)
		)
    )
                                        (.  complex =  
												staticCall ?? 
												member ??
												complex; 
										.)
    //Reference
|   pointer                             (.  var ptrCount = 1; .)
    {   pointer                         (.  ptrCount++; .)
    }
    Id<out id>                          (.  complex = _assembleReference(id, ptrCount); .)
|   question
    [   Integer<out placeholderIndex> ] (.  complex = new AstPlaceholder(this, 0 <= placeholderIndex ? (int?)placeholderIndex : null); .)
.

VariableDeclaration<out AstGetSet complex>
                                (.  string id, physicalId;
                                    bool isOverrideDecl = false;
                                    bool seenVar = false;
                                    int refCount = 1;
                                    bool isUnbound = false;
                                    bool isStatic = false;
                                    Symbol sym, varSym;
                                .)
=
[   new                         (.  isUnbound = true; .)
]
(       static                  (.  isStatic = true; .)
        {   ref                 (.  refCount++; .)
        }
        [   var     ]
    |   (   var                 (.  seenVar = true; .)
        |    ref                (.  refCount++; .)
        )
        {   (   var             (.  if(seenVar)
                                    {
                                        Loader.ReportMessage(Message.Error("Duplicate ocurrence of `var` in local variable declaration.",GetPosition(),MessageClasses.DuplicateVar));
                                        // This is just a stylistic rule. There are no consequences to having duplicate `var` keywords in a declaration.
                                    }
                                    seenVar = true;
                                .)
            |   ref             (.  refCount++; .)
            )
        }
)
    [   new                     (.  isOverrideDecl = true; .)
    ]                           (.  ISourcePosition position = GetPosition(); .)
    Id<out id>                  (.  physicalId = id;
                                    if(isStatic)
                                    {
                                        physicalId = target.Function.Id + "\\static\\" + id;
                                        VariableDeclaration vari;
                                        if(isOverrideDecl)
                                        {
                                            if(TargetModule.Variables.Contains(physicalId))
                                                physicalId = target.GenerateLocalId(physicalId);
                                        }

                                        DefineGlobalVariable(physicalId, out vari);
                                        varSym = Symbol.CreateReference(EntityRef.Variable.Global.Create(physicalId,TargetModule.Name),position);

                                        if(isUnbound)
                                        {
                                            Loader.ReportMessage(Message.Error("Unbinding of global (or static) variables is not currently supported.",position,MessageClasses.GlobalUnbindNotSupported));
                                            isUnbound = false;
                                        }
                                    }
                                    else
                                    {
                                        if(isOverrideDecl)
                                        {
                                            if(target.Function.Variables.Contains(physicalId))
                                                physicalId = target.GenerateLocalId(physicalId);
                                            target.Function.Variables.Add(physicalId);
                                        }
                                        else if(!isOuterVariable(physicalId))
                                        {
                                            target.Function.Variables.Add(physicalId);
                                        }

                                        varSym = Symbol.CreateReference(EntityRef.Variable.Local.Create(physicalId),position);
                                        // Create.ExprFor will request outer variables where necessary.
                                    }

                                    // Apply ref's (one ref is implied, see initialization of refCount)
                                    //  Note: we retain the original symbol to generate the AST node
                                    sym = varSym;
                                    while(refCount-- > 0)
                                        sym = Symbol.CreateDereference(sym);
                                    
                                    // Declare the symbol in the current scope and assemble an AST node
                                    Symbols.Declare(id,sym);
                                    complex = Create.ExprFor(position, Symbol.CreateDereference(varSym)) as AstGetSet;

                                    if(complex == null)
                                    {
                                        Loader.ReportMessage(Message.Error("Expected variable declaration to result in LValue.",position,MessageClasses.LValueExpected));
                                        complex = Create.IndirectCall(position,Create.Null(position));
                                    }
                                    else if(isUnbound)
                                    {
                                        // Wrap variable access in NewDecl
                                        var newDecl = new AstGetSetNewDecl(this)
													    {
														    Expression = complex,
														    Id = physicalId
													    };
                                        complex = newDecl;
                                    }
                                .)
.

SymbolicUsage<out AstGetSet complex>
                                (.  string id; ISourcePosition position; 
                                .)
=                               (.  position = GetPosition(); .)
    Id<out id>                  (.  Symbol sym;
                                    var expr = Symbols.TryGet(id, out sym)
                                        ? Create.ExprFor(position, sym)
                                        : new AstUnresolved(position, id);
                                    complex = expr as AstGetSet;
                                    if(complex == null)
                                    {
                                        Loader.ReportMessage(Message.Error("Expected symbolic usage to be represented as an LValue.",position,MessageClasses.ParserInternal));
                                        complex = Create.IndirectCall(position,Create.Null(position));
                                    }
                                .)
    Arguments<complex.Arguments>    
.

StaticCall<out AstGetSetStatic staticCall>
                                (.  AstTypeExpr typeExpr;
                                    string memberId;
                                .)
=
    ExplicitTypeExpr<out typeExpr>
    dot Id<out memberId>        (.  staticCall = new AstGetSetStatic(this, PCall.Get, typeExpr, memberId); .)
    Arguments<staticCall.Arguments>
.

/*
StaticCall<out AstGetSetStatic staticCall>
                                (.  string id = "";
                                    System.Text.StringBuilder idBuilder = new System.Text.StringBuilder();
                                    bool staticPrefix = false;
                                .)
=

    [   doublecolon             (.  staticPrefix = true; .)
    ]   Ns<out id>              (.  idBuilder.Append(id); .)
    {   Ns<out id>              (.  idBuilder.Append("."+id); .)
    }
    Id<out id>                  (.  staticCall = createStaticCall(idBuilder.ToString(), id, staticPrefix); .)
    Arguments<staticCall.Arguments> 
. // */
                                    //Fallback in case of a syntax error to avoid NullReferenceExceptions
ExplicitLabel<AstBlock block>   (.  string id = "--\\NotAnId\\--"; .)
=
    (   Id<out id> colon
    |   lid                     (.  id = cache(t.val.Substring(0,t.val.Length-1)); .)
    )                           (.  block.Statements.Add(new AstExplicitLabel(this, id)); .)
.

ExplicitGoTo<AstBlock block>    (.  string id; .)
=
    goto
    Id<out id>                  (.  block.Statements.Add(new AstExplicitGoTo(this, id)); .)
.

Assignment<AstGetSet lvalue, out AstNode node>
                                (.  AstExpr expr = null;
									BinaryOperator setModifier = BinaryOperator.None;
									AstTypeExpr typeExpr;
									node = lvalue;
                                    ISourcePosition position;
								.)
=                               (.  position = GetPosition(); .)
(                               
	(   ( assign )              (.  setModifier = BinaryOperator.None; .)
	|   plus assign             (.  setModifier = BinaryOperator.Addition; .)
	|   minus assign            (.  setModifier = BinaryOperator.Subtraction; .)
	|   times assign            (.  setModifier = BinaryOperator.Multiply; .)
	|   div assign              (.  setModifier = BinaryOperator.Division; .)
	|   bitAnd assign           (.  setModifier = BinaryOperator.BitwiseAnd; .)
	|   bitOr assign            (.  setModifier = BinaryOperator.BitwiseOr; .)
	|	coalescence assign      (.	setModifier = BinaryOperator.Coalescence; .)
	)   Expr<out expr>        //(.	expr = expr; .)
	
|	(	tilde assign            (.	setModifier = BinaryOperator.Cast; .)
	)	TypeExpr<out typeExpr>  (.  expr = typeExpr; .)
)								
								(.  if(expr == null)
                                    {
                                        Loader.ReportMessage(Message.Error("Internal error during translation of assignment. This is likely caused by an error reported previously.",GetPosition(),MessageClasses.ParserInternal));
                                    }
                                    else
                                    {
                                        lvalue.Arguments.Add(expr);
                                    }
									lvalue.Call = PCall.Set; 
									if(setModifier != BinaryOperator.None)
									    node = Create.ModifyingAssignment(position,lvalue,setModifier);
								.)
.

Condition<AstBlock block>
                                (. AstExpr expr; bool isNegative = false; .)
=
    (   if                      (.  /* isNegative is already false */ .)
    |   unless                  (.  isNegative = true; .)
    )
    
    lpar Expr<out expr> rpar    (.  if(expr == null)
                                        expr = _createUnknownExpr();
                                    AstCondition cond = Create.Condition(GetPosition(), expr, isNegative);
                                    _PushScope(cond.IfBlock);
                                .)
    
    StatementBlock<cond.IfBlock> 
                                (.  _PopScope(cond.IfBlock); .)

    
    [   else                    (.  _PushScope(cond.ElseBlock); .)
        StatementBlock<cond.ElseBlock> 
                                (.  _PopScope(cond.ElseBlock); .)
    ]                           (.  block.Add(cond); .)
.

WhileLoop<AstBlock block>
                                (.  AstWhileLoop loop = new AstWhileLoop(GetPosition(),CurrentBlock); .)
=
(   (   while  | until          (.  loop.IsPositive = false; .)    
    )                           
    lpar Expr<out loop.Condition> rpar
                                (.  _PushScope(loop.Block); //EndBlock is common for both loops
                                .)
    StatementBlock<loop.Block> 
    
|   do                          (.  _PushScope(loop.Block); 
                                    loop.IsPrecondition = false;
                                .)
    StatementBlock<loop.Block>
    (   while  | until          (.  loop.IsPositive = false; .)    
    )                           
    lpar Expr<out loop.Condition> rpar
)                               (.  _PopScope(loop.Block); block.Add(loop); .)
.

ForLoop<AstBlock block>         (.  AstForLoop loop;
									AstExpr condition;
                                .)
=
    for                         (.  loop = new AstForLoop(GetPosition(), CurrentBlock); 
									_PushScope(loop.Initialize);
								.)
    lpar StatementBlock<loop.Initialize>
    (							(.	
									_PushScope(loop.NextIteration); 
								.)
		do StatementBlock<loop.NextIteration> 
                                (.  loop.IsPrecondition = false; .)
        (   while
        |   until               (.  loop.IsPositive = false; .)
        )						(.  _PopScope(loop.NextIteration); .)
        Expr<out condition>		(.	loop.Condition = condition; 
									_PushScope(loop.NextIteration);
								.)
    |   [   while
        |   until               (.  loop.IsPositive = false; .)
        ]       
        Expr<out condition>		(.	loop.Condition = condition; .)
        semicolon				(.	_PushScope(loop.NextIteration); .)
        SimpleStatement<loop.NextIteration>
        [ semicolon ]
    )							
    rpar						(.  _PushScope(loop.Block); .)
    StatementBlock<loop.Block>  (.  _PopScope(loop.Block);
									_PopScope(loop.NextIteration);
									_PopScope(loop.Initialize);
									block.Add(loop);
								.)
.

ForeachLoop<AstBlock block>
=
    foreach                      (.  AstForeachLoop loop = Create.ForeachLoop(GetPosition());
                                     _PushScope(loop.Block);
                                 .)
    lpar
    GetCall<out loop.Element> 
    in 
    Expr<out loop.List> 
    rpar
    StatementBlock<loop.Block>
                                (.  _PopScope(loop.Block);
                                    block.Add(loop); 
                                .) 
.

GetCall<out AstGetSet complex>  // This is used in placed where an LValue is expected
                                // as the name of this production so helpfully suggests ;-)
                                // Thus checking for LValue-ness is required and expected.
                                (.  AstGetSet getMember = null; 
                                    AstExpr expr;
                                .)
=
    GetInitiator<out expr>
                                (.  complex = expr as AstGetSet;
                                    if(complex == null)
                                    {
                                        var pos = GetPosition();
                                        Loader.ReportMessage(Message.Error("Expected an LValue (Get/Set-Complex) for ++,-- or assignment statement.",pos,MessageClasses.LValueExpected));
                                        complex = Create.IndirectCall(pos,Create.Null(pos));
                                    }  
                                .)
    { GetSetExtension<complex, out getMember> 
                                (.  complex = getMember; .)
    }
.

Return<AstBlock block>          (.  AstReturn ret = null; 
                                    AstExplicitGoTo jump = null; 
                                    AstExpr expr; 
                                    AstLoopBlock bl = target.CurrentLoopBlock;
                                .)
=
(   
    (
        return                  (.  ret = new AstReturn(this, ReturnVariant.Exit); .)
    |   yield                   (.  ret = new AstReturn(this, ReturnVariant.Continue); .)
    )
    [   Expr<out expr>          (.  ret.Expression = expr; .)
    |   assign                  (.  ret.ReturnVariant = ReturnVariant.Set; .)
        Expr<out expr>          (.  ret.Expression = expr; .)
                                (.  SemErr("Return value assignment is no longer supported. You must use local variables instead."); .)
    ]
|   break                       (.  if(bl == null)
                                        ret = new AstReturn(this, ReturnVariant.Break); 
                                    else
                                        jump = new AstExplicitGoTo(this, bl.BreakLabel);
                                .)
|   continue                    (.  if(bl == null)
                                        ret = new AstReturn(this, ReturnVariant.Continue); 
                                    else
                                        jump = new AstExplicitGoTo(this, bl.ContinueLabel);
                                .)
)                               (.  block.Add((AstNode)ret ?? jump); .)
.

NestedFunction<AstBlock block>
                                (.  PFunction func; .)
=
    FunctionDefinition<out func>
                                (.  
                                    string logicalId = func.Meta[PFunction.LogicalIdKey];
                                    func.Meta[PFunction.ParentFunctionKey] = target.Function.Id;
                                    
                                    CompilerTarget ft = FunctionTargets[func];
                                    var pos = GetPosition();
                                    var setVar = Create.IndirectCall(pos,Create.Reference(pos,EntityRef.Variable.Local.Create(logicalId)),PCall.Set);
                                    if(func.Meta[PFunction.LazyKey].Switch)
                                    {
                                        //Capture environment by value                                        
                                        var ps = ft._ToCaptureByValue(let_bindings(ft));
                                        ft._DetermineSharedNames(); //Need to re-determine shared names since
                                                                    // _ToCaptureByValue does not automatically modify shared names
                                        var clos = Create.CreateClosure(pos,  EntityRef.Function.Create(func.Id, 
                                                func.ParentApplication.Module.Name));
                                        var callStub = Create.IndirectCall(pos, clos);
                                        callStub.Arguments.AddRange(ps(this));
                                        setVar.Arguments.Add(callStub);
                                    }
                                    else if(ft.OuterVariables.Count > 0)
                                    {                                        
                                        setVar.Arguments.Add( Create.CreateClosure(GetPosition(),  EntityRef.Function.Create(func.Id, 
                                                func.ParentApplication.Module.Name)) );                                        
                                    }
                                    else
                                    {
                                        setVar.Arguments.Add( new AstReference(GetPosition(), EntityRef.Function.Create(func.Id,func.ParentApplication.Module.Name)) );
                                    }
                                    block.Add(setVar);
                                .)
.

LetBindingStmt<AstBlock block>
=
    let LetBinder<block> { comma LetBinder<block> }
.

LetBinder<AstBlock block>
                                (.  string id = null;
                                    AstExpr thunk;
                                .)
=                               (.  var position = GetPosition(); .)
    Id<out id>                  (.  //Declare local "let" variable
                                    SmartDeclareLocal(id, SymbolInterpretations.LocalObjectVariable);
                                    mark_as_let(target.Function, id);
                                    if(la.kind == _assign)
                                        _inject(_lazy,"lazy"); 
                                .)
    [   assign                      
        LazyExpression<out thunk>   
                                (.  
                                    //Assign thunk to that variable
                                    var assign = Create.Call(position, EntityRef.Variable.Local.Create(id), PCall.Set);
                                    assign.Arguments.Add(thunk);
                                    block.Add(assign);
                                .)
    ]
.

TryCatchFinally<AstBlock block>
                                (.  var a = Create.TryCatchFinally(GetPosition());
                                    AstGetSet excVar;
                                .)
=
    try                         (.  _PushScope(a);
									_PushScope(a.TryBlock); 
								.)
    lbrace
    {   Statement<a.TryBlock>
    }
    rbrace                      (. /* Don't pop try-block scope here. */ .)
    [	catch                   (. _PushScope(a.CatchBlock); .)
		(   lpar
			GetCall<out excVar> (. a.ExceptionVar = excVar; .)
			rpar
	    |                       (.  SemErr(la,"catch-clauses that don't store the exception are illegal."); .)
		)
		lbrace
		{   Statement<a.CatchBlock>
		}
		rbrace		            (. _PopScope(a.CatchBlock);.)
	    
		[
			finally             (.  _PushScope(a.FinallyBlock); .)
			lbrace
			{   Statement<a.FinallyBlock>
			}
			rbrace              (.  _PopScope(a.FinallyBlock); .)
		]
		
	|	finally                 (.  _PushScope(a.FinallyBlock); .)
		lbrace
		{   Statement<a.FinallyBlock>
		}
		rbrace                  (.  _PopScope(a.FinallyBlock); .)
		
		[	                    (.  _PushScope(a.CatchBlock); .)
		    catch
			(   lpar
				GetCall<out excVar>
                                (. a.ExceptionVar = excVar; .)
				rpar
			|                   (.  SemErr(la,"catch-clauses that don't store the exception are illegal."); .)
			)
			lbrace
			{   Statement<a.CatchBlock>
			}
			rbrace
			                    (.  _PopScope(a.CatchBlock); .)
		]
	]                       
                                (.  _PopScope(a.TryBlock);
									_PopScope(a);
									block.Add(a); 
								.)
.

Throw<AstBlock block>
                                (.  AstThrow th; .)
=
	ThrowExpression<out th>
                                (.  block.Add(th); .)
.                                

Using<AstBlock block>
                                (.  AstUsing use = Create.Using(GetPosition());
									AstExpr e;
								.)
=
								(.  _PushScope(use);
									_PushScope(use.Block); .)
    uusing lpar Expr<out e> rpar
								(.	use.ResourceExpression = e; .)
                                
    StatementBlock<use.Block>
                                (.  _PopScope(use.Block);
									_PopScope(use);
                                    block.Add(use); 
                                .)
.

Arguments<ArgumentsProxy args>
                                (.  
									AstExpr expr;
                                    bool missingArg = false;
                                .)
=
	[
		lpar
		[	Expr<out expr>      (.  args.Add(expr); .)
			{	comma           (.  if(missingArg)
                                        SemErr("Missing argument expression (two consecutive commas)");
                                .)
				(   Expr<out expr>  
                                (.  args.Add(expr);
                                    missingArg = false;
                                .)
                |               (.  missingArg = true; .)
                )
			}
		]
		rpar
	]
								(.	args.RememberRightAppendPosition(); .)
	[
		appendleft
		(
			IF(la.kind == _lpar && (!isLambdaExpression()))
			lpar
			[	Expr<out expr>	(.  args.Add(expr); .)
				{	comma
					Expr<out expr>	
								(.  args.Add(expr); .)
				}
			]
			rpar
		|	Expr<out expr>		(.  args.Add(expr); .)
		)
	]
.
#file:C:\Users\Christian\Documents\GitHub\prx\Prexonite\Compiler\Grammar\Footer.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

END Prexonite.#file:default#
